<!DOCTYPE html>
      <html>
          <head>
          <meta charset="utf-8" >
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <title>hook.md</title>
          <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github-gist.min.css" rel="stylesheet">  
          <style>
              .markdown-body {
                  box-sizing: border-box;
                  min-width: 200px;
                  max-width: 980px;
                  margin: 0 auto;
                  padding: 45px;
              }
              .markdown-body img {
                  box-sizing: border-box !important;
                  margin:10px 0 10px 2%;
                  padding: 20px;
                  width: 96%;
                  border-radius: 4px;
                  box-shadow: 0 0 6px 0px #999;
              }
              @media (max-width: 767px) {
                  .markdown-body {
                      padding: 15px;
                  }
              }
              @font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,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) format('woff')}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}.markdown-body .anchor:focus{outline:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .pl-c{color:#6a737d}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#005cc5}.markdown-body .pl-e,.markdown-body .pl-en{color:#6f42c1}.markdown-body .pl-s .pl-s1,.markdown-body .pl-smi{color:#24292e}.markdown-body .pl-ent{color:#22863a}.markdown-body .pl-k{color:#d73a49}.markdown-body .pl-pds,.markdown-body .pl-s,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sra,.markdown-body .pl-sr .pl-sre{color:#032f62}.markdown-body .pl-smw,.markdown-body .pl-v{color:#e36209}.markdown-body .pl-bu{color:#b31d28}.markdown-body .pl-ii{background-color:#b31d28;color:#fafbfc}.markdown-body .pl-c2{background-color:#d73a49;color:#fafbfc}.markdown-body .pl-c2:before{content:"^M"}.markdown-body .pl-sr .pl-cce{color:#22863a;font-weight:700}.markdown-body .pl-ml{color:#735c0f}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{color:#005cc5;font-weight:700}.markdown-body .pl-mi{color:#24292e;font-style:italic}.markdown-body .pl-mb{color:#24292e;font-weight:700}.markdown-body .pl-md{background-color:#ffeef0;color:#b31d28}.markdown-body .pl-mi1{background-color:#f0fff4;color:#22863a}.markdown-body .pl-mc{background-color:#ffebda;color:#e36209}.markdown-body .pl-mi2{background-color:#005cc5;color:#f6f8fa}.markdown-body .pl-mdr{color:#6f42c1;font-weight:700}.markdown-body .pl-ba{color:#586069}.markdown-body .pl-sg{color:#959da5}.markdown-body .pl-corl{color:#032f62;text-decoration:underline}.markdown-body details{display:block}.markdown-body summary{display:list-item}.markdown-body a{background-color:transparent}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body strong{font-weight:inherit;font-weight:bolder}.markdown-body h1{font-size:2em;margin:.67em 0}.markdown-body img{border-style:none}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace;font-size:1em}.markdown-body hr{box-sizing:content-box;height:0;overflow:visible}.markdown-body input{font:inherit;margin:0}.markdown-body input{overflow:visible}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body input{font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body a{color:#0366d6;text-decoration:none}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{background:0 0;border:0;border-bottom:1px solid #dfe2e5;height:0;margin:15px 0;overflow:hidden}.markdown-body hr:before{content:"";display:table}.markdown-body hr:after{clear:both;content:"";display:table}.markdown-body table{border-collapse:collapse;border-spacing:0}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-bottom:0;margin-top:0}.markdown-body h1{font-size:32px}.markdown-body h1,.markdown-body h2{font-weight:600}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:20px}.markdown-body h3,.markdown-body h4{font-weight:600}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:14px}.markdown-body h5,.markdown-body h6{font-weight:600}.markdown-body h6{font-size:12px}.markdown-body p{margin-bottom:10px;margin-top:0}.markdown-body blockquote{margin:0}.markdown-body ol,.markdown-body ul{margin-bottom:0;margin-top:0;padding-left:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code,.markdown-body pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px}.markdown-body pre{margin-bottom:0;margin-top:0}.markdown-body input::-webkit-inner-spin-button,.markdown-body input::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}.markdown-body .border{border:1px solid #e1e4e8!important}.markdown-body .border-0{border:0!important}.markdown-body .border-bottom{border-bottom:1px solid #e1e4e8!important}.markdown-body .rounded-1{border-radius:3px!important}.markdown-body .bg-white{background-color:#fff!important}.markdown-body .bg-gray-light{background-color:#fafbfc!important}.markdown-body .text-gray-light{color:#6a737d!important}.markdown-body .mb-0{margin-bottom:0!important}.markdown-body .my-2{margin-bottom:8px!important;margin-top:8px!important}.markdown-body .pl-0{padding-left:0!important}.markdown-body .py-0{padding-bottom:0!important;padding-top:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .py-2{padding-bottom:8px!important;padding-top:8px!important}.markdown-body .pl-3,.markdown-body .px-3{padding-left:16px!important}.markdown-body .px-3{padding-right:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body .f6{font-size:12px!important}.markdown-body .lh-condensed{line-height:1.25!important}.markdown-body .text-bold{font-weight:600!important}.markdown-body:before{content:"";display:table}.markdown-body:after{clear:both;content:"";display:table}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-bottom:16px;margin-top:0}.markdown-body hr{background-color:#e1e4e8;border:0;height:.25em;margin:24px 0;padding:0}.markdown-body blockquote{border-left:.25em solid #dfe2e5;color:#6a737d;padding:0 1em}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:10px;padding:3px 5px;vertical-align:middle}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{font-weight:600;line-height:1.25;margin-bottom:16px;margin-top:24px}.markdown-body h1{font-size:2em}.markdown-body h1,.markdown-body h2{border-bottom:1px solid #eaecef;padding-bottom:.3em}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{color:#6a737d;font-size:.85em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-bottom:0;margin-top:0}.markdown-body li{word-wrap:break-all}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{font-size:1em;font-style:italic;font-weight:600;margin-top:16px;padding:0}.markdown-body dl dd{margin-bottom:16px;padding:0 16px}.markdown-body table{display:block;overflow:auto;width:100%}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:6px 13px}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{background-color:#fff;box-sizing:content-box;max-width:100%}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body code{background-color:rgba(27,31,35,.05);border-radius:3px;font-size:85%;margin:0;padding:.2em .4em}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{background:0 0;border:0;font-size:100%;margin:0;padding:0;white-space:pre;word-break:normal}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{background-color:#f6f8fa;border-radius:3px;font-size:85%;line-height:1.45;overflow:auto;padding:16px}.markdown-body pre code{background-color:transparent;border:0;display:inline;line-height:inherit;margin:0;max-width:auto;overflow:visible;padding:0;word-wrap:normal}.markdown-body .commit-tease-sha{color:#444d56;display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:90%}.markdown-body .blob-wrapper{border-bottom-left-radius:3px;border-bottom-right-radius:3px;overflow-x:auto;overflow-y:hidden}.markdown-body .blob-wrapper-embedded{max-height:240px;overflow-y:auto}.markdown-body .blob-num{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;color:rgba(27,31,35,.3);cursor:pointer;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;line-height:20px;min-width:50px;padding-left:10px;padding-right:10px;text-align:right;user-select:none;vertical-align:top;white-space:nowrap;width:1%}.markdown-body .blob-num:hover{color:rgba(27,31,35,.6)}.markdown-body .blob-num:before{content:attr(data-line-number)}.markdown-body .blob-code{line-height:20px;padding-left:10px;padding-right:10px;position:relative;vertical-align:top}.markdown-body .blob-code-inner{color:#24292e;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;overflow:visible;white-space:pre;word-wrap:normal}.markdown-body .pl-token.active,.markdown-body .pl-token:hover{background:#ffea7f;cursor:pointer}.markdown-body kbd{background-color:#fafbfc;border:1px solid #d1d5da;border-bottom-color:#c6cbd1;border-radius:3px;box-shadow:inset 0 -1px 0 #c6cbd1;color:#444d56;display:inline-block;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:10px;padding:3px 5px;vertical-align:middle}.markdown-body :checked+.radio-label{border-color:#0366d6;position:relative;z-index:1}.markdown-body .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}.markdown-body .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}.markdown-body .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}.markdown-body .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}.markdown-body .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}.markdown-body .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}.markdown-body .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}.markdown-body .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}.markdown-body .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}.markdown-body .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}.markdown-body .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}.markdown-body .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body .pl-7{padding-left:48px!important}.markdown-body .pl-8{padding-left:64px!important}.markdown-body .pl-9{padding-left:80px!important}.markdown-body .pl-10{padding-left:96px!important}.markdown-body .pl-11{padding-left:112px!important}.markdown-body .pl-12{padding-left:128px!important}
/*# sourceMappingURL=github-markdown.min.css.map */
          </style>
          <script>
              window.onload = function() {
                hljs.initHighlighting()
              }
          </script>
          </head>
          <body>
            <article class="markdown-body">
                <h3 id="什么是-hook？">什么是 hook？</h3>
<p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。
如果不使用 hook 函数时组件是没有状态的。</p>
<blockquote>
<p>没有破坏性。完全可选，100%向后兼容。</p>
</blockquote>
<p><em>使用 hook 的动机。</em></p>
<ul>
<li><p>在组件之间复用状态逻辑很难。hook 为共享状态逻辑提供更好的原生途径。
<em>Hook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。</em></p>
</li>
<li><p>复杂组件变得难以理解。
我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。
<em>Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。</em></p>
</li>
<li><p>class 带来的问题。</p>
<ul>
<li>this 的绑定问题。</li>
<li>class 不能很好的压缩，并且会使热重载出现不稳定的情况。</li>
</ul>
</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>保证每次渲染时 hook 的调用顺序是不变的。</li>
<li>Hook 不能在 class 组件中使用。</li>
<li>只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在 React 的函数组件中调用 Hook。不要在其他 JavaScript 函数中调用。还有一个地方可以调用 Hook —— 就是自定义的 Hook 中</li>
</ul>
<h3 id="usestate"><code>useState()</code></h3>
<p>通过在函数组件里调用它来给组件添加一些内部 state。React 会在重复渲染时保留这个 state。useState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并。</p>
<pre><code class="language-jsx">import React, { useState } from &quot;react&quot;;

function Example() {
  // 声明一个新的叫做 “count” 的 state 变量
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<h3 id="useeffect"><code>useEffect()</code></h3>
<p>你之前可能已经在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。
useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount、componentDidUpdate 和 componentWillUnmount</code>具有相同的用途，只不过被合并成了一个 API。</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &quot;react&quot;;

function Example() {
  const [count, setCount] = useState(0);

  // 相当于 componentDidMount 和 componentDidUpdate:
  useEffect(() =&gt; {
    // 使用浏览器的 API 更新页面标题
    document.title = `You clicked ${count} times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<h5 id="特点"><code>特点</code></h5>
<ul>
<li><p>当你调用 useEffect 时，就是在告诉 React 在完成对 DOM 的更改后运行你的“副作用”函数。</p>
</li>
<li><p>由于副作用函数是在组件内声明的，所以它们可以访问到组件的 props 和 state。默认情况下，React 会在每次渲染后调用副作用函数 —— 包括第一次渲染的时候。</p>
</li>
<li><p>副作用函数还可以通过返回一个函数来指定如何“清除”副作用。</p>
</li>
</ul>
<pre><code class="language-jsx">import React, { useState, useEffect } from &quot;react&quot;;

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  //  React 会在组件销毁时取消对 ChatAPI 的订阅，然后在后续渲染时重新执行副作用函数。
  // （如果传给 ChatAPI 的 props.friend.id 没有变化，你也可以告诉 React 跳过重新订阅。）
  useEffect(() =&gt; {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return &quot;Loading...&quot;;
  }
  return isOnline ? &quot;Online&quot; : &quot;Offline&quot;;
}</code></pre>
<h3 id="自定义-hook"><code>自定义 hook</code></h3>
<p>有时候我们会想要在组件之间重用一些状态逻辑。目前为止，有两种主流方案来解决这个问题：高阶组件和 render props。
自定义 Hook 可以让你在不增加组件的情况下达到同样的目的。</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &quot;react&quot;;

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() =&gt; {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}</code></pre>
<h3 id="usememo"><code>useMemo</code></h3>
<blockquote>
<p>useMemo 是针对一个函数，是否多次执行。
useMemo 主要用来解决使用 React hooks 产生的无用渲染的性能问题。
在方法函数，由于不能使用 shouldComponentUpdate 处理性能问题，react hooks 新增了 useMemo</p>
</blockquote>
<h5 id="使用">使用</h5>
<blockquote>
<p>如果 <code>useMemo(fn, arr)</code> 第二个参数匹配，并且其值发生改变，才会多次执行执行，否则只执行一次，如果为空数组[]，fn 只执行一次。</p>
</blockquote>
<p>举例说明：</p>
<p>第一次进来时，控制台显示 rich child，当无限点击按钮时，控制台不会打印 rich child。
但是当改变 props.name 为 props.isChild 时，每点击一次按钮，控制台就会打印一次 rich child。</p>
<pre><code class="language-jsx">export default () =&gt; {
  let [isChild, setChild] = useState(false);

  return (
    &lt;div&gt;
      &lt;Child isChild={isChild} name=&quot;child&quot; /&gt;
      &lt;button onClick={() =&gt; setChild(!isChild)}&gt;改变Child&lt;/button&gt;
    &lt;/div&gt;
  );
};

let Child = (props) =&gt; {
  let getRichChild = () =&gt; {
    console.log(&quot;rich child&quot;);

    return &quot;rich child&quot;;
  };

  // 使用了useMemo后，只要props.name没有发生变化就不会重复执行getRichChild
  let richChild = useMemo(() =&gt; {
    //执行相应的函数
    return getRichChild();
  }, [props.name]);

  return (
    &lt;div&gt;
      isChild: {props.isChild ? &quot;true&quot; : &quot;false&quot;}
      &lt;br /&gt;
      {richChild}
    &lt;/div&gt;
  );
};</code></pre>
<h5 id="解决的问题？">解决的问题？</h5>
<p>解决了函数式组件内部逻辑函数不必要的重复执行, 通过<code>useMemo</code>的第二个参数来控制当那些数据改变后才会重复执行。</p>
<h3 id="usecallback"><code>useCallback()</code></h3>
<h5 id="解决的问题？-1">解决的问题？</h5>
<p>在函数式组件内部给子组件绑定事件时, 每次重新渲染时都会绑定一个新的事件函数(因为每次更新组件函数时都会产生一个新的闭包),
从而导致子组件的不必要更新。使用<code>useCallback</code>解决了这个问题，<code>useCallback</code>会将事件处理函数缓存起来, 每次更新的时候都是绑定的同一个函数。</p>
<h5 id="使用方式">使用方式</h5>
<pre><code class="language-jsx">import React, { useState, memo, useMemo, useCallback } from &quot;react&quot;;

const Child = memo((props) =&gt; {
  console.log(props);

  return (
    &lt;div&gt;
      &lt;input type=&quot;text&quot; onChange={props.onChange} /&gt;
    &lt;/div&gt;
  );
});

const Parent = () =&gt; {
  const [count, setCount] = useState(0);
  const [text, setText] = useState(&quot;&quot;);

  const handleOnChange = useCallback((e) =&gt; {
    setText(e.target.value);
  }, []);

  return (
    &lt;div&gt;
      &lt;div&gt;count: {count}&lt;/div&gt;
      &lt;div&gt;text: {text}&lt;/div&gt;
      &lt;button
        onClick={() =&gt; {
          setCount(count + 1);
        }}
      &gt;
        +1
      &lt;/button&gt;
      &lt;Child onChange={handleOnChange} /&gt;
    &lt;/div&gt;
  );
};</code></pre>
<blockquote>
<p><em>对比 useMemo，useMemo 缓存的是一个值，useCallback 缓存的是一个函数。</em></p>
</blockquote>
<h3 id="useref"><code>useRef()</code></h3>
<h5 id="作用">作用</h5>
<ul>
<li>用来获取组件实例对象或者是 DOM 对象。</li>
</ul>
<pre><code class="language-jsx">import React, { useState, useEffect, useMemo, useRef } from &quot;react&quot;;

export default function App(props) {
  const [count, setCount] = useState(0);

  const doubleCount = useMemo(() =&gt; {
    return 2 * count;
  }, [count]);

  const couterRef = useRef();

  useEffect(() =&gt; {
    document.title = `The value is ${count}`;
    console.log(couterRef.current);
  }, [count]);

  return (
    &lt;&gt;
      &lt;button
        ref={couterRef}
        onClick={() =&gt; {
          setCount(count + 1);
        }}
      &gt;
        Count: {count}, double: {doubleCount}
      &lt;/button&gt;
    &lt;/&gt;
  );
}</code></pre>
<ul>
<li>除了传统的用法之外，它还可以“跨渲染周期”保存数据。</li>
</ul>
<p>在一个组件中有什么东西可以跨渲染周期，也就是在组件被多次渲染之后依旧不变的属性？第一个想到的应该是 state。没错，一个组件的 state 可以在多次渲染之后依旧不变。但是，state 的问题在于一旦修改了它就会造成组件的重新渲染。
那么这个时候就可以使用 useRef 来跨越渲染周期存储数据，而且对它修改也不会引起组件渲染。</p>
<pre><code class="language-jsx">import React, { useState, useEffect, useMemo, useRef } from &quot;react&quot;;

export default function App(props) {
  const [count, setCount] = useState(0);

  const doubleCount = useMemo(() =&gt; {
    return 2 * count;
  }, [count]);

  // react将ref的缓存起来了
  const timerID = useRef();

  useEffect(() =&gt; {
    timerID.current = setInterval(() =&gt; {
      setCount((count) =&gt; count + 1);
    }, 1000);
  }, []);

  useEffect(() =&gt; {
    if (count &gt; 10) {
      clearInterval(timerID.current);
    }
  });

  return (
    &lt;&gt;
      &lt;button
        ref={couterRef}
        onClick={() =&gt; {
          setCount(count + 1);
        }}
      &gt;
        Count: {count}, double: {doubleCount}
      &lt;/button&gt;
    &lt;/&gt;
  );
}</code></pre>
<h3 id="uselayouteffect"><code>useLayoutEffect()</code></h3>
<blockquote>
<p>其函数签名与 useEffect 相同，但它会<em>在所有的 DOM 变更之后同步调用 effect</em>。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>
</blockquote>
<ul>
<li><code>useEffect</code>和<code>useLayoutEffect</code>的区别？</li>
</ul>
<p><code>useEffect</code> 在渲染时是异步执行，并且要等到浏览器将所有变化渲染到屏幕后才会被执行。
<code>useLayoutEffect</code> 在渲染时是同步执行，其执行时机与 <code>componentDidMount</code>，<code>componentDidUpdate</code> 一致。</p>
<ul>
<li>对于 useEffect 和 useLayoutEffect 哪一个与 componentDidMount，componentDidUpdate 的是等价的？</li>
</ul>
<p>useLayoutEffect，因为从源码中调用的位置来看，useLayoutEffect 的 create 函数的调用位置、时机都和 componentDidMount，componentDidUpdate 一致，
且都是被 React 同步调用，都会阻塞浏览器渲染。</p>
<ul>
<li>useEffect 和 useLayoutEffect 哪一个与 componentWillUnmount 的是等价的？</li>
</ul>
<p>同上，useLayoutEffect 的 detroy 函数的调用位置、时机与 componentWillUnmount 一致，且都是同步调用。
useEffect 的 detroy 函数从调用时机上来看，更像是 componentDidUnmount (注意 React 中并没有这个生命周期函数)。</p>
<ul>
<li>为什么建议将修改 DOM 的操作里放到 useLayoutEffect 里，而不是 useEffect？</li>
</ul>
<p>DOM 已经被修改，但但浏览器渲染线程依旧处于被阻塞阶段，所以还没有发生回流、重绘过程。由于内存中的 DOM 已经被修改，通过 useLayoutEffect 可以拿到最新的 DOM 节点，并且在此时对 DOM 进行样式上的修改，假设修改了元素的 height，这些修改会在步骤 11 和 react 做出的更改一起被一次性渲染到屏幕上，依旧只有一次回流、重绘的代价。</p>
<p>如果放在 useEffect 里，useEffect 的函数会在组件渲染到屏幕之后执行，此时对 DOM 进行修改，会触发浏览器再次进行回流、重绘，增加了性能上的损耗。</p>
<h3 id="usereducer"><code>useReducer()</code></h3>
<blockquote>
<p>尽管 useReducer 是扩展的 hook， 而 useState 是基本的 hook，但 useState 实际上执行的也是一个 useReducer。
这意味着 useReducer 是更原生的，你能在任何使用 useState 的地方都替换成使用 useReducer。</p>
</blockquote>
<ul>
<li>与<code>useState</code>一样都返回当前状态和一个改变状态的函数。</li>
<li>比<code>useState</code>更强大, 出了接受一个初始值作为第二个参数外， 还接受一个定义改变状态值逻辑的函数。</li>
</ul>
<pre><code class="language-jsx">function ShoppingList() {
  const inputRef = useRef();
  const [items, dispatch] = useReducer((state, action) =&gt; {
    switch (action.type) {
      case &#39;add&#39;:
        return [
          ...state,
          {
            id: state.length,
            name: action.name
          }
        ];
      default:
        return state;
    }
  }, []);

  function handleSubmit(e) {
    e.preventDefault();
    dispatch({
      type: &#39;add&#39;,
      name: inputRef.current.value
    });
    inputRef.current.value = &#39;&#39;;
  }

  return (
    // ... same ...
  );
}
</code></pre>
<ul>
<li>任何使用<code>useState</code>的地方都可以使用<code>useReducer</code>代替</li>
</ul>
<pre><code class="language-jsx">function Test() {
  const [count, setCount] = useState(0)
  const [count, setCount] = useReducer((state, action) =&gt; {
    return action
  }, 0)


  return (
    // ...
  )
}</code></pre>
<h3 id="useimperativehandle">useImperativeHandle</h3>
<p>正常情况下 <code>ref</code> 是不能挂在到函数组件上的，因为函数组件没有实例，但是 <code>useImperativeHandle</code> 为我们提供了一个类似实例的东西。
它帮助我们通过 <code>useImperativeHandle</code> 的第 2 个参数，_所返回的对象的内容挂载到 父组件的 ref.current 上_。</p>
<p><em><code>forwardRef</code> 会创建一个 <code>React</code> 组件，这个组件能够将其接受的 <code>ref</code> 属性转发到其组件树下的另一个组件中。</em></p>
<pre><code class="language-jsx">import React, {
  forwardRef,
  useImperativeHandle,
  useEffect,
  useRef,
} from &quot;react&quot;;

const TestRef = forwardRef((props, ref) =&gt; {
  // 将open方法暴露出去，父组件可以获取到。
  useImperativeHandle(ref, () =&gt; ({
    open() {
      console.log(&quot;open&quot;);
    },
  }));
});

function App() {
  const ref = useRef();
  useEffect(() =&gt; {
    // 这里获取的current对象就是，在TestRef中使用useImperativeHandle定义第二参数的返回值的。
    ref.current.open();
  }, []);

  return (
    &lt;&gt;
      &lt;TestRef ref={ref}&gt;&lt;/TestRef&gt;
    &lt;/&gt;
  );
}
export default App;</code></pre>
<h3 id="总结">总结</h3>
<p>React Hook 让无狀态组件拥有了许多只有有狀态组件的能力，如自更新能力（setState，使用 useState），
访问 ref（使用 useRef 或 useImperativeMethods），
访问 context(使用 useContext)，使用更高级的 setState 设置（useReducer），
及进行类似生命周期的阶段性方法（useEffect 或 useLayoutEffect）。</p>
<p>当然还有一些 Hook，带来了一些新功能，如 useCallback，这是对事件句柄进行缓存，
useState 的第二个返回值是 dispatch，但是每次都是返回新的，使用 useCallback，可以让它使用上次的函数。
在虚拟 DOM 更新过程中，如果事件句柄相同，那么就不用每次都进行 removeEventListner 与 addEventListner。
最后就是 useMemo，取得上次缓存的数据，它可以说是 useCallback 的另一种形式。</p>
<ul>
<li><blockquote>
<p>useState： setState</p>
</blockquote>
</li>
<li><blockquote>
<p>useReducer：setState</p>
</blockquote>
</li>
<li><blockquote>
<p>useRef: ref</p>
</blockquote>
</li>
<li><blockquote>
<p>useImperativeMethods: ref</p>
</blockquote>
</li>
<li><blockquote>
<p>useContext: context</p>
</blockquote>
</li>
<li><blockquote>
<p>useCallback: 可以对 setState 的优化</p>
</blockquote>
</li>
<li><blockquote>
<p>useMemo: useCallback 的变形</p>
</blockquote>
</li>
<li><blockquote>
<p>useLayoutEffect: 类似 componentDidMount/Update, componentWillUnmount</p>
</blockquote>
</li>
<li><blockquote>
<p>useEffect: 类似于 setState(state, cb)中的 cb，总是在整个更新周期的最后才执行</p>
</blockquote>
</li>
</ul>

            </article> 
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>  
          </body>
      </html>