# 1、最新的 ECMAScript 标准定义了 9 种数据类型:
# 2、typeof
# 3、显示类型转换
# 4、隐式类型转换
# 5、作用域
## 静态作用域与动态作用域

# 6、作用域链

# 7、let 和 const 的块级作用域
### var 与 const、let 的区别？
# 8、JavaScript 之执行上下文栈

# 9、变量对象(了解) 

# 10、闭包 

# 11、this 指向

# 原型和原型链

-   https://zhuanlan.zhihu.com/p/87667349

### Function、Object 的关系图

![yuan_xing](.image\yuan_xing.jpg)

### 什么是原型？

-   给其它对象提供共享属性的对象。
-   prototype 描述的是两个对象之间的某种关系（其中一个，为另一个提供属性访问权限）。

### **proto**

### Object.getPrototypeOf(obj)、Object.setPrototypeOf(obj, obj1)

### 原型链

对象 A 的原型对象 B 既然是一个普通的对象，那么对象 B 也会有他自己的原型对象 C, 依次类推 C 也有自己的原型对象, 直到某个对象的原型是 null 为止。
如此, 对象的原型的原型的原型...就成了一条链， 就叫原型链。

> 思考：

-   对象的属性访问过程是怎样的？
-   对象的属性赋值是怎么样的? 赋值原型链上已有的属性？

### 原型继承方式

所谓的原型继承，就是指设置某个对象为另一个对象的原型。

> Object.create()

-   与`Object.setPrototypeOf()`使用场景的区别？

原型式继承。

```js
// 创建对象
const user = {}

// 添加原型
Object.setPrototypeOf(user, Object.prototype)

// 扩展属性
obj.firstName = 'zhang'
obj.lastName = 'san'
```

显而易见，这样的继承方式过于繁琐。

### 构造函数加原型继承

```js
function User(firstName, lastName) {
    this.firstName = firstName
    this.lastName = lastName
}

User.prototype = Object.create(Object.prototype)
User.prototype.constructor = User

const user = new User('zhang', 'san')
```

> 对象字面量，创建对象的过程

-   1、隐式的`new Object()`创建对象
-   2、隐式的进行原型继承

### `Class`继承与原型继承

> class 继承

-   class 是用于创造对象的模板，所有具体的对象，都由这个对象模板 + 参数产生出来。
-   通常来说，data 数据是由 instance 承载，而 methods 行为/方法则在 class 里。也就是说通过 class 继承，继承的是结构(数据结构)和方法。

> 与原型继承的区别

-   基于 prototype 的继承，可以继承数据、结构和行为三者。

> 在 JS 中， class 的继承是通过原型来模拟的。为了迎合 class 的基本行为。prototype 继承数据的能力被屏蔽了。

```js
class Test {
    a = 1
    constructor(b) {
        this.b = b
    }
    show() {
        return a + b
    }
}
```

> class 只是语法糖而已。class 能实现的原型都能实现。
> 语法糖不一定提供了更强的表达能力，往往相反，语法糖主要是为了开发者的便利性而设计。

### 从数据结构与算法的角度理解 prototype 和 class

-   JS Prototype 原型对应的数据结构和算法是什么？
-   访问原型链的过程就是一个访问链表的过程。

### 原型会可能会带来的问题

-   1、隐式访问原型属性让程序更不可靠，也容易带来困惑
    看下面的例子：

```js
const Obj = {
    hasOwnProperty() {
        return true
    },
}
Obj.hasOwnProperty('f') // 永远返回true
```

所以几乎所有的 js 库，都是使用下面的代码判断：

```js
const hasOwn = Object.hasOwnProperty()
hasOwn.call(Obj, 'f')
```

_它们会先将 Object.prototype.hasOwnProperty 保存在一个变量里，然后通过 call 的方式去调用。如此可以保证 hasOwnProperty 的行为，明确知道它是在 Object.prototype 层面的方法。_

-   2、在原型上追加数据和方法，会影响到所有继承该原型的对象。随意修改内置对象 Array、String 等的原型会造成全局污染，引起不必要的麻烦。
    _大家认为这种做法，相当于对全局变量和命名空间的滥用。很多年前，整个前端开发社区就达成了高度的共识，如无必要，不要随意往原型上拓展方法，特别是全局构造函数里的原型。_

-   3、基于 prototype 和 class 编写的代码，很难通过代码分析，在构建时进行移除不必要的代码。这项技术叫 Tree-Shaking 或者 Dead Code Elimination。

-   4、不利于代码复用。
    比如 react hook 解决了 class 组件的逻辑复用问题。在 class-component 里，我们需要在同一个生命周期里做不同的事情，并且在不同的生命周期里协调同一件事情的不同阶段。

# bind

```js
function bind(fn, thisObj) {
    return function () {
        thisObj.__fn__ = fn
        thisObj.__fn__()
        thisObj.__fn__ = void 0
    }
}

var bfn = bind(
    function () {
        console.log(this.a)
    },
    { a: 1 }
)
bfn() // 1
```

> 思考

-   如果 this 要绑定 null 呢？

# call

```js
function call(fn, thisObj) {
    thisObj.__fn__ = fn
    thisObj.__fn__()
    thisObj.__fn__ = void 0
}

call(
    function () {
        console.log(this.a)
    },
    { a: 1 }
) // 1
```

# 手写 Promise

# setImmediate、setTimeout 的区别？

# 防抖、节流

# 介绍下深度优先遍历和广度优先遍历，如何实现？

```js
let tree = {
    value: 1,
    children: [
        {
            value: 2,
            children: [
                {
                    value: 6,
                },
            ],
        },
        {
            value: 3,
            children: [
                {
                    value: 7,
                },
            ],
        },
        {
            value: 4,
            children: [
                {
                    value: 8,
                },
            ],
        },
        {
            value: 5,
        },
    ],
}

// 深度优先
function visitTree(tree) {
    if (!tree) return
    console.log(tree.value)
    if (tree.children) {
        for (let i = 0; i < tree.children.length; i++) {
            visitTree(tree.children[i])
        }
    }
}

// 广度优先
function visitTree1(tree) {
    if (!tree) return
    console.log(tree.value)
    const queue = [tree]
    let i
    while ((i = queue.shift())) {
        console.log(i.value)
        if (i.children) {
            i.children.forEach(item => {
                queue.push(item)
            })
        }
    }
}
```

# ES5/ES6 的继承除了写法以外还有什么区别？

> 题目： https://github.com/yygmind/blog/issues/43

# 执行顺序

```js
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start')
setTimeout(function () {
    console.log('setTimeout')
}, 0)
async1()
new Promise(function (resolve) {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('promise2')
})
console.log('script end')

// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

# JS 异步解决方案的发展历程以及优缺点。

# 通信

### 同源

-   协议、域名、端口都相同才是同源。

### 同源策略限制

> 限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。
> 不同源的 JS 只能未经允许地发数据，不能未经允许地读数据。

-   cookie、storage、indexDB 的访问
-   dom 的访问
-   ajax 请求

### 为什么 form 提交不会有跨域行为而 ajax 有？

跨域是浏览器行为，而且具体行为是，你的请求可以发送，浏览器也能收到正常的响应，只是返回给你的时候，浏览器检查了是不是跨域，是对话就阻止了。
form 提交(submit 函数)之后，是不会有任何数据返回的。你没机会读任何东西，所以可以认为是无害的，不在同源策略之内。
但 Ajax 是有数据返回的。所以是浏览器认为是可能有害的。

-   不管请求是否跨域， 关键是能否获取到服务器返回的信息，如果能获取到那么跨域就是危险的。
-   跨域请求其实是将请求发送到了服务器，只是返回结果被浏览器拦截了。

### 简单请求跨域和复杂请求跨域

-   简单跨域会直接将请求发送到服务器
-   复杂请求会先发送预请求 options，只有当预请求发送成功后才会发送实际的请求。

### 前后端如何通信

-   ajax
-   websocket
-   cors （Cross Origin Resource Sharing 跨来源资源共享）

### 跨域通信

-   1、jsonp
-   2、postMessage
-   3、cors
-   4、websocket
-   5、对于嵌套的不同域页面可以使用 url 上的 hash 值传递消息

# 跨窗口通信

# 输入 URL 到页面渲染的过程

-   1、DNS 解析得到 ip 地址
    -   DNS 负载均衡
-   2、通过 ip 地址向服务器发送一个 http 请求
    -   TCP 连接。 三次握手。
    -   http 缓存、浏览器缓存
    -   nginx 反向代理
-   3、请求返回 html 文件

# TCP 三次握手， 四次挥手

### 三次握手

-   目的：防止 server 端一直等待，浪费资源。

# 重定向 301 和 302

# 负载均衡

# nginx 反向代理

# csrf
