https://zhuanlan.zhihu.com/p/33058983

https://html.spec.whatwg.org/multipage/webappapis.html#event-loops

https://segmentfault.com/a/1190000021295911

### 为什么是单线程？
原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。

### 线程非阻塞？
非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

### 事件队列
js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。

### macro task与micro task
当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。

### 一、任务队列： 宏任务， 微任务, RAF
> 执行顺序 微任务 > RAF > Channel > 宏任务

1. 执行一个宏任务(先执行同步代码)-->
2. 执行所有微任务-->
3. UI render-->
4. 执行下一个宏任务-->
5. 执行所有微任务-->
6. UI render-->......

> 根据HTML Standard，一轮事件循环执行结束之后，下轮事件循环执行之前开始进行UI render。
> 即：macro-task任务执行完毕，接着执行完所有的micro-task任务后，此时本轮循环结束，开始执行UI render。
> UI render完毕之后接着下一轮循环。但是UI render不一定会执行，因为需要考虑ui渲染消耗的性能以及有没有ui变动。

### 二、宏任务
setTimeout()

### 三、微任务
Promise.resolve()、queueMicrotask()、MutationObserver
使用Promise.resolve和queueMicrotask、MutationObserver的优先级是一样的。
1、为什么需要使用微任务？
从微任务本身的概念来说的话，就是当我们期望某段代码，**不阻塞当前执行的同步代码，同时又期望它尽可能快地执行时**，我们就需要它

### 四、RAF
requestAnimationFrame()

### 五、channel
MessageChannel

```js
function Observer(userCallBack) {
  // 选择需要观察变动的节点
  const targetNode = document.createElement('div');

  // 观察器的配置（需要观察什么变动）
  const config = {
    attributes: true,
    childList: true,
    subtree: true
  };

  // 当观察到变动时执行的回调函数
  const callback = function (mutationsList, observer) {
    // Use traditional 'for loops' for IE 11
    // for (let mutation of mutationsList) {
    //   if (mutation.type === 'childList') {
    //     console.log('A child node has been added or removed.');
    //   } else if (mutation.type === 'attributes') {
    //     console.log('The ' + mutation.attributeName + ' attribute was modified.');
    //     userCallBack()
    //   }
    // }
    userCallBack()
    // 之后，可停止观察
    observer.disconnect();
  };

  // 创建一个观察器实例并传入回调函数
  const observer = new MutationObserver(callback);

  // 以上述配置开始观察目标节点
  observer.observe(targetNode, config);
  targetNode.id = targetNode.id == 0 ? 1 : 0
}

function channel(callback) {
  var channel = new MessageChannel();
  var port1 = channel.port1;
  var port2 = channel.port2;
  port2.onmessage = function (event) {
    callback()
  }
  port1.postMessage('');
}

setTimeout(() => {
  console.log('setTimeout')
})
channel(() => {
  console.log('channel')
})
requestAnimationFrame(() => {
  console.log('requestAnimationFrame')
})
Promise.resolve().then(() => {
  console.log('Promise')
})

Observer(() => {
  console.log('Observer')
})
queueMicrotask(() => {
  console.log('queueMicrotask')
})


console.log('sync')
```