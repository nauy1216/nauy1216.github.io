# 1、最新的 ECMAScript 标准定义了 9 种数据类型:

# 2、typeof

# 3、显示类型转换

# 4、隐式类型转换

# 5、作用域
## 静态作用域与动态作用域

# 6、作用域链

# 7、let 和 const 的块级作用域
### var 与 const、let 的区别？

# 8、JavaScript 之执行上下文栈

# 9、变量对象(了解) 

# 10、闭包 

# 11、this 指向


# 12、原型和原型链

# 13、 bind

```js
function bind(fn, thisObj) {
    return function () {
        thisObj.__fn__ = fn
        thisObj.__fn__()
        thisObj.__fn__ = void 0
    }
}

var bfn = bind(
    function () {
        console.log(this.a)
    },
    { a: 1 }
)
bfn() // 1
```

> 思考
-   如果 this 要绑定 null 呢？

# 14、call

```js
function call(fn, thisObj) {
    thisObj.__fn__ = fn
    thisObj.__fn__()
    thisObj.__fn__ = void 0
}

call(
    function () {
        console.log(this.a)
    },
    { a: 1 }
) // 1
```

# 15、手写 Promise

# 16、setImmediate、setTimeout 的区别？

# 17、防抖、节流

# 18、介绍下深度优先遍历和广度优先遍历，如何实现？

```js
let tree = {
    value: 1,
    children: [
        {
            value: 2,
            children: [
                {
                    value: 6,
                },
            ],
        },
        {
            value: 3,
            children: [
                {
                    value: 7,
                },
            ],
        },
        {
            value: 4,
            children: [
                {
                    value: 8,
                },
            ],
        },
        {
            value: 5,
        },
    ],
}

// 深度优先
function visitTree(tree) {
    if (!tree) return
    console.log(tree.value)
    if (tree.children) {
        for (let i = 0; i < tree.children.length; i++) {
            visitTree(tree.children[i])
        }
    }
}

// 广度优先
function visitTree1(tree) {
    if (!tree) return
    console.log(tree.value)
    const queue = [tree]
    let i
    while ((i = queue.shift())) {
        console.log(i.value)
        if (i.children) {
            i.children.forEach(item => {
                queue.push(item)
            })
        }
    }
}
```

# 19、ES5/ES6 的继承除了写法以外还有什么区别？

> 题目： https://github.com/yygmind/blog/issues/43

# 20、执行顺序

```js
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start')
setTimeout(function () {
    console.log('setTimeout')
}, 0)
async1()
new Promise(function (resolve) {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('promise2')
})
console.log('script end')

// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

# 21、JS 异步解决方案的发展历程以及优缺点。

# 22、通信
1. 同源
2. 同源策略限制
3. 为什么 form 提交不会有跨域行为而 ajax 有？
4. 简单请求跨域和复杂请求跨域
5. 跨域通信

# 23、跨窗口通信

# 24、输入 URL 到页面渲染的过程
# 25、TCP 三次握手， 四次挥手

### 26、三次握手

-   目的：防止 server 端一直等待，浪费资源。

# 27、 重定向 301 和 302

# 28、缓存304
1. 请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？

# 29、负载均衡

# 30、nginx 反向代理

# 31、csrf
# 32、xss

# 33、cookie 和 token 都存放在 header 中，为什么不会劫持 token？

# 34、数组flatten 

# 35、实现一个 sleep 函数
```js
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(resolve, time)
  })
}

async function test() {
  console.log(0)
  await sleep(1000)
  console.log(1)
}

test()
```

# 36、为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？
英文术语叫：image beacon。
一般做法是服务器用一个1x1的gif图片来作为响应，当然这有点浪费服务器资源。因此用header来响应比较合适，目前比较合适的做法是服务器发送"204 No Content"，即“服务器成功处理了请求，但不需要返回任何实体内容”。另外该脚本的位置一般放在页面最后以免阻塞页面渲染,并且一般情况下也不需要append到DOM中。通过它的onerror和onload事件来检测发送状态。
### 特点
- 能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
- 触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
- 跨域友好
- 执行过程无阻塞
- 相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
- GIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）
- 使用的时候注意图片会有缓存。

# 37、实现 (5).add(3).minus(2) 功能
```js
Number.prototype.add = function add(number) {
  return this.valueOf() + number
}
Number.prototype.minus = function minus(number) {
  return this.valueOf() - number
}

console.log((5).add(4).minus(1)) // 8
```

# 38、Vue 的响应式原理中 Object.defineProperty 有什么缺陷？

# 39、sort的默认排序

# 40
```js
var a = {n: 1};
var b = a;
a.x = a = {n: 2};

console.log(a.x) 	
console.log(b.x)
```

# 40、冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？

# 41、某公司 1 到 12 月份的销售额存在一个对象里面
如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。

# 42、Symbol.iterator
```js
var arr = [1, 2, 3]
var iterator = arr[Symbol.iterator]()
console.log(iterator.next()) // {value: 1, done: false}
console.log(iterator.next()) // {value: 2, done: false}
console.log(iterator.next()) // {value: 1, done: false}
console.log(iterator.next()) // {value: undefined, done: true}
```

# 43、要求设计 LazyMan 类，实现以下功能。
```js
LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony').sleep(10).eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

```js
class LazyMan {
  constructor(name) {
    if (!(this instanceof LazyMan)) {
      console.log('call')
      return new LazyMan(name)
    }
    this.name = name
    this.queue = []
    console.log(`Hi I am ${name}`)

    setTimeout(async () => {
      for (let fn of this.queue) {
        await fn()
      }
    })
  }

  sleepFirst(time) {
    this.queue.unshift(() => {
      return new Promise(resolve => {
        setTimeout(() => {
          console.log(`等待了${time}秒...`)
          resolve()
        }, time)
      })
    })
    return this
  }

  sleep(time) {
    this.queue.push(() => {
      return new Promise(resolve => {
        setTimeout(() => {
          console.log(`等待了${time}秒...`)
          resolve()
        }, time)
      })
    })
    return this
  }

  eat(food) {
    this.queue.push(() => {
      console.log(`I am eating ${food}`)
    })
    return this
  }
}
```

# 44、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。

# 45、箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

# 46、已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。
```html
<img src="1.jpg" style="width:480px!important;”>
```

# 47、 如何设计实现无缝轮播
# 48、模拟实现一个 Promise.finally
# 49、a.b.c.d 和 a['b']['c']['d']，哪个性能更高？
# 50、ES6 代码转成 ES5 代码的实现思路是什么
# 51、如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 。
# 52、介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的
# 53、为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因。
# 54
```js
function fn() {
   'use strict';
    console.log(this) // undefined
}
```

# 55、数组里面有10万个数据，取第一个元素和第10万个元素的时间相差多少
# 56、使用 JavaScript Proxy 实现简单的数据绑定
```js
function typeOf(obj) {
  return Object.prototype.toString.call(obj).slice(8, -1)
}

function Observer(data) {
  const DepMap = new Map()
  return new Proxy(data, {
    set(obj, prop, value) {
      // console.log('set', obj, prop, value)
      let oldValue = obj[prop]
      let newValue = obj[prop] = typeOf(value) === 'Object' ? Observer(value) : value
      if (oldValue !== newValue) {
        let dep = DepMap.get(prop)
        if (dep) {
          dep.notify()
        }
      }
    },
    get(obj, prop) {
      // console.log('get', obj, prop)
      if (!DepMap.has(prop) && prop in obj) {
        DepMap.set(prop, new Dep())
      }
      let dep = DepMap.get(prop)
      let value = obj[prop]
      if (typeOf(value) === 'Object') {
        value = Observer(value)
      }
      if (Dep.target) {
        dep.depend(Dep.target)
      }
      return value
    },
    deleteProperty(obj, prop) {
      delete obj[prop]
      let dep = DepMap.get(prop)
      if (dep) {
        dep.notify()
        DepMap.delete(prop)
      }
      console.log('deleteProperty', obj, prop)
    }
  })
}

class Dep {
  constructor() {
    this.subscribe = []
  }
  depend(effect) {
    this.subscribe.push(effect)
    effect.depend(this)
  }
  cancel(effect) {
    let index = this.subscribe.indexOf(effect)
    if (index > -1) {
      this.subscribe.splice(index, 1)
    }
  }
  notify() {
    let arr = this.subscribe.slice()
    for (let effect of arr) {
      try {
        effect.exec()
      } catch (e) {
        console.error(e)
      }
    }
  }
}
Dep.target = null

function effect(callback) {
  if (typeOf(callback) === 'Function' && !callback._effect) {
    const effectObj = {
      value: undefined,
      deps: [],
      depend(dep) {
        this.deps.push(dep)
      },
      cancel() {
        this.deps.forEach((dep) => {
          dep.cancel(this)
        })
        this.deps = []
      }
    }
    callback._effect = effectObj
    effectObj.exec = callback
    Dep.target = effectObj
    callback()
  }
  return () => {
    callback._effect.cancel()
    callback._effect = undefined
  }
}

let p = Observer([1, 2])
let cancel = effect(() => {
  console.log('effect ===> p[0]', p[0])
})
// // console.log('p.b.c', p.b.c)
// // cancel()
setTimeout(() => {
  p[0] = 6
}, 2000)

```

# 57、 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
```js
// 输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
// 输出: [5, 6, 7, 1, 2, 3, 4]

arr.splice(-k).concat(arr)
```

# 58、Vue 的父组件和子组件生命周期钩子执行顺序是什么
# 59、请实现一个 add 函数，满足以下功能。
```js
add(1); 			// 1
add(1)(2);  	// 3
add(1)(2)(3)；// 6
add(1)(2, 3); // 6
add(1, 2)(3); // 6
add(1, 2, 3); // 6
```

# 60、将index作为key的坑
```js
new Vue({
    data() {
        return {
            list: [1, 2, 3]
        }
    },
    methods: {
        handleClick() {
            this.list.push(Math.random())
            // this.list.unshift(Math.random()) 
        }
    },
    template:`
        <div @click="handleClick">
            <div v-for="(item, index) in list" :key="index>{{item}}</div>
        </div>
    `
})
```

# 61、将index作为key的好处？