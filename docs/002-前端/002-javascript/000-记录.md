# 1、最新的 ECMAScript 标准定义了 9 种数据类型:
# 2、typeof
# 3、显示类型转换
# 4、隐式类型转换
# 5、作用域
## 静态作用域与动态作用域

# 6、作用域链

# 7、let 和 const 的块级作用域
### var 与 const、let 的区别？
# 8、JavaScript 之执行上下文栈

# 9、变量对象(了解) 

# 10、闭包 

# 11、this 指向

# 12、原型和原型链
# bind

```js
function bind(fn, thisObj) {
    return function () {
        thisObj.__fn__ = fn
        thisObj.__fn__()
        thisObj.__fn__ = void 0
    }
}

var bfn = bind(
    function () {
        console.log(this.a)
    },
    { a: 1 }
)
bfn() // 1
```

> 思考

-   如果 this 要绑定 null 呢？

# call

```js
function call(fn, thisObj) {
    thisObj.__fn__ = fn
    thisObj.__fn__()
    thisObj.__fn__ = void 0
}

call(
    function () {
        console.log(this.a)
    },
    { a: 1 }
) // 1
```

# 手写 Promise

# setImmediate、setTimeout 的区别？

# 防抖、节流

# 介绍下深度优先遍历和广度优先遍历，如何实现？

```js
let tree = {
    value: 1,
    children: [
        {
            value: 2,
            children: [
                {
                    value: 6,
                },
            ],
        },
        {
            value: 3,
            children: [
                {
                    value: 7,
                },
            ],
        },
        {
            value: 4,
            children: [
                {
                    value: 8,
                },
            ],
        },
        {
            value: 5,
        },
    ],
}

// 深度优先
function visitTree(tree) {
    if (!tree) return
    console.log(tree.value)
    if (tree.children) {
        for (let i = 0; i < tree.children.length; i++) {
            visitTree(tree.children[i])
        }
    }
}

// 广度优先
function visitTree1(tree) {
    if (!tree) return
    console.log(tree.value)
    const queue = [tree]
    let i
    while ((i = queue.shift())) {
        console.log(i.value)
        if (i.children) {
            i.children.forEach(item => {
                queue.push(item)
            })
        }
    }
}
```

# ES5/ES6 的继承除了写法以外还有什么区别？

> 题目： https://github.com/yygmind/blog/issues/43

# 执行顺序

```js
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start')
setTimeout(function () {
    console.log('setTimeout')
}, 0)
async1()
new Promise(function (resolve) {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('promise2')
})
console.log('script end')

// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

# JS 异步解决方案的发展历程以及优缺点。

# 通信

### 同源

-   协议、域名、端口都相同才是同源。

### 同源策略限制

> 限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。
> 不同源的 JS 只能未经允许地发数据，不能未经允许地读数据。

-   cookie、storage、indexDB 的访问
-   dom 的访问
-   ajax 请求

### 为什么 form 提交不会有跨域行为而 ajax 有？

跨域是浏览器行为，而且具体行为是，你的请求可以发送，浏览器也能收到正常的响应，只是返回给你的时候，浏览器检查了是不是跨域，是对话就阻止了。
form 提交(submit 函数)之后，是不会有任何数据返回的。你没机会读任何东西，所以可以认为是无害的，不在同源策略之内。
但 Ajax 是有数据返回的。所以是浏览器认为是可能有害的。

-   不管请求是否跨域， 关键是能否获取到服务器返回的信息，如果能获取到那么跨域就是危险的。
-   跨域请求其实是将请求发送到了服务器，只是返回结果被浏览器拦截了。

### 简单请求跨域和复杂请求跨域

-   简单跨域会直接将请求发送到服务器
-   复杂请求会先发送预请求 options，只有当预请求发送成功后才会发送实际的请求。

### 前后端如何通信

-   ajax
-   websocket
-   cors （Cross Origin Resource Sharing 跨来源资源共享）

### 跨域通信

-   1、jsonp
-   2、postMessage
-   3、cors
-   4、websocket
-   5、对于嵌套的不同域页面可以使用 url 上的 hash 值传递消息

# 跨窗口通信

# 输入 URL 到页面渲染的过程

-   1、DNS 解析得到 ip 地址
    -   DNS 负载均衡
-   2、通过 ip 地址向服务器发送一个 http 请求
    -   TCP 连接。 三次握手。
    -   http 缓存、浏览器缓存
    -   nginx 反向代理
-   3、请求返回 html 文件

# TCP 三次握手， 四次挥手

### 三次握手

-   目的：防止 server 端一直等待，浪费资源。

# 重定向 301 和 302

# 负载均衡

# nginx 反向代理

# csrf
