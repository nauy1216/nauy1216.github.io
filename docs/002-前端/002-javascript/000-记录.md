# 1、最新的 ECMAScript 标准定义了 9 种数据类型:

# 2、typeof

# 3、显示类型转换

# 4、隐式类型转换

# 5、作用域
## 静态作用域与动态作用域

# 6、作用域链

# 7、let 和 const 的块级作用域
### var 与 const、let 的区别？

# 8、JavaScript 之执行上下文栈

# 9、变量对象(了解) 

# 10、闭包 

# 11、this 指向


# 12、原型和原型链

# 13、 bind

```js
function bind(fn, thisObj) {
    return function () {
        thisObj.__fn__ = fn
        thisObj.__fn__()
        thisObj.__fn__ = void 0
    }
}

var bfn = bind(
    function () {
        console.log(this.a)
    },
    { a: 1 }
)
bfn() // 1
```

> 思考
-   如果 this 要绑定 null 呢？

# 14、call

```js
function call(fn, thisObj) {
    thisObj.__fn__ = fn
    thisObj.__fn__()
    thisObj.__fn__ = void 0
}

call(
    function () {
        console.log(this.a)
    },
    { a: 1 }
) // 1
```

# 15、手写 Promise

# 16、setImmediate、setTimeout 的区别？

# 17、防抖、节流

# 18、介绍下深度优先遍历和广度优先遍历，如何实现？

```js
let tree = {
    value: 1,
    children: [
        {
            value: 2,
            children: [
                {
                    value: 6,
                },
            ],
        },
        {
            value: 3,
            children: [
                {
                    value: 7,
                },
            ],
        },
        {
            value: 4,
            children: [
                {
                    value: 8,
                },
            ],
        },
        {
            value: 5,
        },
    ],
}

// 深度优先
function visitTree(tree) {
    if (!tree) return
    console.log(tree.value)
    if (tree.children) {
        for (let i = 0; i < tree.children.length; i++) {
            visitTree(tree.children[i])
        }
    }
}

// 广度优先
function visitTree1(tree) {
    if (!tree) return
    console.log(tree.value)
    const queue = [tree]
    let i
    while ((i = queue.shift())) {
        console.log(i.value)
        if (i.children) {
            i.children.forEach(item => {
                queue.push(item)
            })
        }
    }
}
```

# 19、ES5/ES6 的继承除了写法以外还有什么区别？

> 题目： https://github.com/yygmind/blog/issues/43

# 20、执行顺序

```js
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}
async function async2() {
    console.log('async2')
}
console.log('script start')
setTimeout(function () {
    console.log('setTimeout')
}, 0)
async1()
new Promise(function (resolve) {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('promise2')
})
console.log('script end')

// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

# 21、JS 异步解决方案的发展历程以及优缺点。

# 22、通信
1. 同源
2. 同源策略限制
3. 为什么 form 提交不会有跨域行为而 ajax 有？
4. 简单请求跨域和复杂请求跨域
5. 跨域通信

# 跨窗口通信

# 输入 URL 到页面渲染的过程
# TCP 三次握手， 四次挥手

### 三次握手

-   目的：防止 server 端一直等待，浪费资源。

# 重定向 301 和 302

# 缓存304

# 负载均衡

# nginx 反向代理

# csrf
# xss
