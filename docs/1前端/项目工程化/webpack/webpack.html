<!DOCTYPE html>
      <html>
          <head>
          <meta charset="utf-8" >
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <title>webpack.md</title>
          <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github-gist.min.css" rel="stylesheet">  
          <style>
              .markdown-body {
                  box-sizing: border-box;
                  min-width: 200px;
                  max-width: 980px;
                  margin: 0 auto;
                  padding: 45px;
              }
              .markdown-body img {
                  box-sizing: border-box !important;
                  margin:10px 0 10px 2%;
                  padding: 20px;
                  width: 96%;
                  border-radius: 4px;
                  box-shadow: 0 0 6px 0px #999;
              }
              @media (max-width: 767px) {
                  .markdown-body {
                      padding: 15px;
                  }
              }
              @font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,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) format('woff')}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}.markdown-body .anchor:focus{outline:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .pl-c{color:#6a737d}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#005cc5}.markdown-body .pl-e,.markdown-body .pl-en{color:#6f42c1}.markdown-body .pl-s .pl-s1,.markdown-body .pl-smi{color:#24292e}.markdown-body .pl-ent{color:#22863a}.markdown-body .pl-k{color:#d73a49}.markdown-body .pl-pds,.markdown-body .pl-s,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sra,.markdown-body .pl-sr .pl-sre{color:#032f62}.markdown-body .pl-smw,.markdown-body .pl-v{color:#e36209}.markdown-body .pl-bu{color:#b31d28}.markdown-body .pl-ii{background-color:#b31d28;color:#fafbfc}.markdown-body .pl-c2{background-color:#d73a49;color:#fafbfc}.markdown-body .pl-c2:before{content:"^M"}.markdown-body .pl-sr .pl-cce{color:#22863a;font-weight:700}.markdown-body .pl-ml{color:#735c0f}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{color:#005cc5;font-weight:700}.markdown-body .pl-mi{color:#24292e;font-style:italic}.markdown-body .pl-mb{color:#24292e;font-weight:700}.markdown-body .pl-md{background-color:#ffeef0;color:#b31d28}.markdown-body .pl-mi1{background-color:#f0fff4;color:#22863a}.markdown-body .pl-mc{background-color:#ffebda;color:#e36209}.markdown-body .pl-mi2{background-color:#005cc5;color:#f6f8fa}.markdown-body .pl-mdr{color:#6f42c1;font-weight:700}.markdown-body .pl-ba{color:#586069}.markdown-body .pl-sg{color:#959da5}.markdown-body .pl-corl{color:#032f62;text-decoration:underline}.markdown-body details{display:block}.markdown-body summary{display:list-item}.markdown-body a{background-color:transparent}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body strong{font-weight:inherit;font-weight:bolder}.markdown-body h1{font-size:2em;margin:.67em 0}.markdown-body img{border-style:none}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace;font-size:1em}.markdown-body hr{box-sizing:content-box;height:0;overflow:visible}.markdown-body input{font:inherit;margin:0}.markdown-body input{overflow:visible}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body input{font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body a{color:#0366d6;text-decoration:none}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{background:0 0;border:0;border-bottom:1px solid #dfe2e5;height:0;margin:15px 0;overflow:hidden}.markdown-body hr:before{content:"";display:table}.markdown-body hr:after{clear:both;content:"";display:table}.markdown-body table{border-collapse:collapse;border-spacing:0}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-bottom:0;margin-top:0}.markdown-body h1{font-size:32px}.markdown-body h1,.markdown-body h2{font-weight:600}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:20px}.markdown-body h3,.markdown-body h4{font-weight:600}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:14px}.markdown-body h5,.markdown-body h6{font-weight:600}.markdown-body h6{font-size:12px}.markdown-body p{margin-bottom:10px;margin-top:0}.markdown-body blockquote{margin:0}.markdown-body ol,.markdown-body ul{margin-bottom:0;margin-top:0;padding-left:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code,.markdown-body pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px}.markdown-body pre{margin-bottom:0;margin-top:0}.markdown-body input::-webkit-inner-spin-button,.markdown-body input::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}.markdown-body .border{border:1px solid #e1e4e8!important}.markdown-body .border-0{border:0!important}.markdown-body .border-bottom{border-bottom:1px solid #e1e4e8!important}.markdown-body .rounded-1{border-radius:3px!important}.markdown-body .bg-white{background-color:#fff!important}.markdown-body .bg-gray-light{background-color:#fafbfc!important}.markdown-body .text-gray-light{color:#6a737d!important}.markdown-body .mb-0{margin-bottom:0!important}.markdown-body .my-2{margin-bottom:8px!important;margin-top:8px!important}.markdown-body .pl-0{padding-left:0!important}.markdown-body .py-0{padding-bottom:0!important;padding-top:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .py-2{padding-bottom:8px!important;padding-top:8px!important}.markdown-body .pl-3,.markdown-body .px-3{padding-left:16px!important}.markdown-body .px-3{padding-right:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body .f6{font-size:12px!important}.markdown-body .lh-condensed{line-height:1.25!important}.markdown-body .text-bold{font-weight:600!important}.markdown-body:before{content:"";display:table}.markdown-body:after{clear:both;content:"";display:table}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-bottom:16px;margin-top:0}.markdown-body hr{background-color:#e1e4e8;border:0;height:.25em;margin:24px 0;padding:0}.markdown-body blockquote{border-left:.25em solid #dfe2e5;color:#6a737d;padding:0 1em}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:10px;padding:3px 5px;vertical-align:middle}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{font-weight:600;line-height:1.25;margin-bottom:16px;margin-top:24px}.markdown-body h1{font-size:2em}.markdown-body h1,.markdown-body h2{border-bottom:1px solid #eaecef;padding-bottom:.3em}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{color:#6a737d;font-size:.85em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-bottom:0;margin-top:0}.markdown-body li{word-wrap:break-all}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{font-size:1em;font-style:italic;font-weight:600;margin-top:16px;padding:0}.markdown-body dl dd{margin-bottom:16px;padding:0 16px}.markdown-body table{display:block;overflow:auto;width:100%}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:6px 13px}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{background-color:#fff;box-sizing:content-box;max-width:100%}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body code{background-color:rgba(27,31,35,.05);border-radius:3px;font-size:85%;margin:0;padding:.2em .4em}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{background:0 0;border:0;font-size:100%;margin:0;padding:0;white-space:pre;word-break:normal}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{background-color:#f6f8fa;border-radius:3px;font-size:85%;line-height:1.45;overflow:auto;padding:16px}.markdown-body pre code{background-color:transparent;border:0;display:inline;line-height:inherit;margin:0;max-width:auto;overflow:visible;padding:0;word-wrap:normal}.markdown-body .commit-tease-sha{color:#444d56;display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:90%}.markdown-body .blob-wrapper{border-bottom-left-radius:3px;border-bottom-right-radius:3px;overflow-x:auto;overflow-y:hidden}.markdown-body .blob-wrapper-embedded{max-height:240px;overflow-y:auto}.markdown-body .blob-num{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;color:rgba(27,31,35,.3);cursor:pointer;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;line-height:20px;min-width:50px;padding-left:10px;padding-right:10px;text-align:right;user-select:none;vertical-align:top;white-space:nowrap;width:1%}.markdown-body .blob-num:hover{color:rgba(27,31,35,.6)}.markdown-body .blob-num:before{content:attr(data-line-number)}.markdown-body .blob-code{line-height:20px;padding-left:10px;padding-right:10px;position:relative;vertical-align:top}.markdown-body .blob-code-inner{color:#24292e;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;overflow:visible;white-space:pre;word-wrap:normal}.markdown-body .pl-token.active,.markdown-body .pl-token:hover{background:#ffea7f;cursor:pointer}.markdown-body kbd{background-color:#fafbfc;border:1px solid #d1d5da;border-bottom-color:#c6cbd1;border-radius:3px;box-shadow:inset 0 -1px 0 #c6cbd1;color:#444d56;display:inline-block;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:10px;padding:3px 5px;vertical-align:middle}.markdown-body :checked+.radio-label{border-color:#0366d6;position:relative;z-index:1}.markdown-body .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}.markdown-body .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}.markdown-body .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}.markdown-body .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}.markdown-body .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}.markdown-body .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}.markdown-body .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}.markdown-body .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}.markdown-body .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}.markdown-body .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}.markdown-body .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}.markdown-body .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body .pl-7{padding-left:48px!important}.markdown-body .pl-8{padding-left:64px!important}.markdown-body .pl-9{padding-left:80px!important}.markdown-body .pl-10{padding-left:96px!important}.markdown-body .pl-11{padding-left:112px!important}.markdown-body .pl-12{padding-left:128px!important}
/*# sourceMappingURL=github-markdown.min.css.map */
          </style>
          <script>
              window.onload = function() {
                hljs.initHighlighting()
              }
          </script>
          </head>
          <body>
            <article class="markdown-body">
                <p>[TOC]</p>
<h1 id="1、初始化项目">1、初始化项目</h1>
<p>执行<strong><code>npm init</code></strong> 生成<strong><code>package.json</code></strong>文件</p>
<pre><code>npm init -y</code></pre><p>进入你创建好的目录下（注意创建的目录名字不要和npm包的名字一样）， 执行上面的命令， 你会发现多了一个用于描述项目的json文件。</p>
<h1 id="2、安装webpack">2、安装webpack</h1>
<p>这里我使用的是本地安装， 你也可以安装在全局。</p>
<pre><code>npm install --save-dev webpack</code></pre><p>我安装的webpack版本是4.41.0。</p>
<h1 id="3、安装webpack-cli">3、安装webpack-cli</h1>
<pre><code>npm install webpack-cli --save-dev</code></pre><p>我安装的webpack-cli版本是3.3.9。</p>
<h1 id="4、准备好你的代码">4、准备好你的代码</h1>
<p>创建  index.html</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;webpack-demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;./src/index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>创建  src/index.js</p>
<pre><code class="language-js">function component() {
    var element = document.createElement(&#39;div&#39;);
    element.innerHTML = &#39;hello webpack&#39;;
    return element;
}

document.body.appendChild(component());</code></pre>
<p>此时你的项目结构应该是这样的。</p>
<pre><code class="language-diff">  |- package.json
+ |- index.html
+ |- /src
+   |- index.js</code></pre>
<p>在浏览器中打开  index.html, 你可以看到 “hello webpack”。但是好像并没有什么用， 到目前为止还没有使用到webpack。别急，我们继续改造代码。</p>
<p>在src/index.js中， 我们将component单独抽出来作为一个模块。</p>
<p>创建 src/component.js</p>
<pre><code class="language-js">export default function component() {
    var element = document.createElement(&#39;div&#39;);
    element.innerHTML = &#39;hello webpack&#39;;
    return element;
}</code></pre>
<p>修改 src/index.js</p>
<pre><code>import component from &#39;componet.js&#39;
document.body.appendChild(component());</code></pre><p>然后你再刷新页面， 发现此时页面报错了，因为报了语法错误。但是我们写的代码并没有问题， 所以只能把我们的代码构建成浏览器能够识别的代码，这个时候就该webpack上场了！！！</p>
<h1 id="5、配置webpack">5、配置webpack</h1>
<p>在项目目录下创建 webpack.config.js 文件。</p>
<pre><code class="language-js">const path = require(&#39;path&#39;)

module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        filename: &#39;bundle.js&#39;,
        path: path.resolve(__dirname, &#39;dist&#39;)
    }
}</code></pre>
<p>修改package.json， 增加 <code>&quot;build&quot;: &quot;webpack --config webpack.config.js&quot;</code>。</p>
<p>由于在执行npm 命令时会临时将当前项目下的bin加入全去变量， 所以可以直接使用webpack 命令。</p>
<p>--config 表示webpack在构建时的配置文件。</p>
<pre><code>  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;
  }</code></pre><p>修改index.html</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;webpack-demo&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>刷新浏览器，此时代码运行正常。</p>
<p>到目前为止， 我们已经能够简单的使用webpack了， 是不是很开心^-^</p>
<h1 id="6、管理资源">6、管理资源</h1>
<p>webapck本身是只能加载js模块的， 但是如果我们要加载css文件、图片、字体怎么办？别急， webapck有个叫loader的东西， 可以安装对应的loader来加载你想要加载的模块。</p>
<p><strong>加载css</strong></p>
<p>为了从 JavaScript 模块中 <code>import</code> 一个 CSS 文件，你需要在 <a href="https://www.webpackjs.com/configuration/module"><code>module</code> 配置中</a> 安装并添加 <a href="https://www.webpackjs.com/loaders/style-loader">style-loader</a> 和 <a href="https://www.webpackjs.com/loaders/css-loader">css-loader</a>。</p>
<pre><code>npm install --save-dev style-loader css-loader</code></pre><p>安装好后， 还得在webpack.config.js里配置好呢， 要不webapck可不干了^-^</p>
<pre><code class="language-js">module.exports = {
    entry: &#39;./src/index.js&#39;,
    output: {
        filename: &#39;bundle.js&#39;,
        path: path.resolve(__dirname, &#39;dist&#39;)
    },
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                    &#39;style-loader&#39;,
                    &#39;css-loader&#39;
                ]
            }
        ]
    }
}</code></pre>
<p>我们尝试下创建css/index.css</p>
<pre><code class="language-css">.hello {
    background: red;
}</code></pre>
<p>将css/index.css引入到component.js</p>
<pre><code>require(&#39;./css/index.css&#39;)
module.exports =  function component() {
    var element = document.createElement(&#39;div&#39;);
    element.innerHTML = &#39;hello webpack&#39;;
    element.classList.add(&#39;hello&#39;)
    return element;
}</code></pre><p>编译刷新后， 你就可以看到添加的样式了。</p>
<p><strong>加载图片</strong></p>
<pre><code>npm install --save-dev file-loader</code></pre><p>webapck.config.js 增加代码</p>
<pre><code>{
    test: /\.(png|svg|jpg|gif)$/,
    use: [
        &#39;file-loader&#39;
    ]
}</code></pre><p><strong>加载字体</strong></p>
<p>file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。这就是说，我们可以将它们用于任何类型的文件，包括字体。</p>
<p>webapck.config.js 增加代码</p>
<pre><code>{
    test: /\.(woff|woff2|eot|ttf|otf)$/, // 加载字体
    use: [
        &#39;file-loader&#39;
    ]
}</code></pre><p><strong>加载数据</strong></p>
<p>此外，可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 <code>import Data from &#39;./data.json&#39;</code> 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 <a href="https://github.com/theplatapi/csv-loader">csv-loader</a> 和 <a href="https://github.com/gisikw/xml-loader">xml-loader</a>。</p>
<pre><code>{
    test: /\.(csv|tsv)$/,
    use: [
    &#39;csv-loader&#39;
    ]
},
{
    test: /\.xml$/,
    use: [
    &#39;xml-loader&#39;
    ]
}</code></pre><h1 id="7、管理输出">7、管理输出</h1>
<p>之前的内容都是只有一个打包输出bundle.js， 那如果要同时输出多个问件呢？</p>
<p>可以定义多个入口， 这样就会打包成几个文件了。</p>
<pre><code>entry: { // 定义多个入口
    app: &#39;./src/index.js&#39;,
    component: &#39;./src/component.js&#39;
},
output: {
    filename: &#39;[name].bundle.js&#39;, // 此时输出的文件名应该也是动态的
    path: path.resolve(__dirname, &#39;dist&#39;)
},</code></pre><p>修改之后， 删除dist文件夹再打包就会发现打包出了两个文件： app.bundle.js  和 component.bundle.js 。</p>
<p>但有个问题是， app.bundle.js  会包含 component.bundle.js 的代码。出现这样的结果是可以预料的，这里打包的两个入口时互不干扰的， 但是怎么解决这个问题呢？（这个问题， 我们后面再解决）</p>
<p>此时你一定会发现刷新浏览器之后，又报错了！！！</p>
<p>原来是没找到bundle.js文件， 原来是我们刚刚将输出文件改了个名字。改下index.html文件就好了。</p>
<p>但是， 如果每次输出的文件名都不一样， 那么每打包一次就要改一次代码。</p>
<p>那有解决的办法吗？</p>
<p>有，使用HtmlWebpackPlugin。</p>
<p><strong>使用 html-webpack-plugin插件</strong></p>
<p>安装html-webpack-plugin</p>
<pre><code>npm install --save-dev html-webpack-plugin</code></pre><p>使用插件</p>
<p>webpack.config.js</p>
<pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

plugins: [
    new HtmlWebpackPlugin({
        template: &#39;./index.html&#39; 
    })
]</code></pre><p>使用webpack插件要在plugins下增加一个插件实例。</p>
<p> HtmlWebpackPlugin接受的参数：</p>
<p>template： html模板的路径,。</p>
<p>构建完成后将在dist下生成一个新的index.html文件， 并且生成的js文件也被引入到body里面了。</p>
<p><strong>使用clean-webpack-plugin 插件</strong></p>
<p>在经过多次打包后， 是时候清理 <code>/dist</code> 文件夹下的旧文件啦！</p>
<p>webpack 会生成文件，然后将这些文件放置在 <code>/dist</code> 文件夹中，但是 webpack 无法追踪到哪些文件是实际在项目中用到的。通常，在每次构建前清理 <code>/dist</code> 文件夹，是比较推荐的做法，因此只会生成用到的文件。让我们完成这个需求。</p>
<pre><code>npm install clean-webpack-plugin --save-dev</code></pre><p>webpack.config.js</p>
<pre><code>const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;).CleanWebpackPlugin 

plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
        template: &#39;./index.html&#39;
    })
]</code></pre><blockquote>
<p>你可能会感兴趣，webpack及其插件似乎“知道”应该哪些文件生成。答案是，通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪。如果你对通过其他方式来管理 webpack 的<a href="https://www.webpackjs.com/configuration/output">输出</a>更感兴趣，那么首先了解 manifest 是个好的开始。</p>
<p>通过使用 <a href="https://github.com/danethurber/webpack-manifest-plugin"><code>WebpackManifestPlugin</code></a>，可以直接将数据提取到一个 json 文件，以供使用。</p>
</blockquote>
<p>到此为止我们已经学会了怎么使用webpack了， 是不是觉得很简单^-^。</p>
<h1 id="8、开发">8、开发</h1>
<p>每次修改代码后都得执行npm run build， 然后再刷新浏览器， 这显然很麻烦。</p>
<p>webpack 中有几个不同的选择，可以帮助你在代码发生变化后自动编译代码：</p>
<ol>
<li>webpack&#39;s Watch Mode</li>
<li>webpack-dev-server</li>
<li>webpack-dev-middleware</li>
</ol>
<p>多数场景中，你可能需要使用 <code>webpack-dev-server</code>，但是不妨学习下上面的不同方案。</p>
<h2 id="81、webpacks-watch-mod">8.1、webpack&#39;s Watch Mod</h2>
<p>你可以指示 webpack &quot;watch&quot; 依赖图中的所有文件以进行更改。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。</p>
<p>我们添加一个用于启动 webpack 的观察模式的 npm script 脚本：</p>
<pre><code class="language-json">&quot;scripts&quot;: {
    &quot;watch&quot;: &quot;webpack --watch&quot;,
    &quot;build&quot;: &quot;webpack&quot;
},</code></pre>
<p>其实很简单， 就是在脚本命令上加 --watch 选项。这样每次你修改代码保存是就会重新编译， 但浏览器还是得刷新（应该有热重载的插件吧^-^）</p>
<h2 id="82、webpack-dev-server">8.2、webpack-dev-server</h2>
<p><code>webpack-dev-server</code> 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)。</p>
<pre><code class="language-bash">npm install --save-dev webpack-dev-server</code></pre>
<p>修改webpack.config.js</p>
<pre><code>devServer: {
    port: 8888,
    contentBase: &#39;/dist&#39;// 告诉服务器从哪里查找文件
}</code></pre><p>以上配置告知 <code>webpack-dev-server</code>，在 <code>localhost:8888</code> 下建立服务，将 <code>dist</code> 目录下的文件，作为可访问文件。</p>
<p>让我们添加一个 script 脚本，可以直接运行开发服务器：</p>
<pre><code>&quot;start&quot;: &quot;webpack-dev-server --open --config webpack.config.js&quot;</code></pre><p>启动服务后，访问localhost:8888， 修改代码可以看到页面内容已经自动刷新了。</p>
<blockquote>
<p>这种方式的刷新是全量刷新的。</p>
</blockquote>
<h2 id="83、webpack-dev-middleware">8.3、webpack-dev-middleware</h2>
<p><code>webpack-dev-middleware</code> 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)。 <code>webpack-dev-server</code> 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求。接下来是一个 webpack-dev-middleware 配合 express server 的示例。</p>
<blockquote>
<p>Vue ssr(服务器端渲染就是使用的这个插件)</p>
</blockquote>
<p>首先，安装 <code>express</code> 和 <code>webpack-dev-middleware</code>：</p>
<pre><code>npm install --save-dev express webpack-dev-middleware</code></pre><p>创建server.js</p>
<pre><code class="language-js">const express = require(&#39;express&#39;);
const webpack = require(&#39;webpack&#39;);
const webpackDevMiddleware = require(&#39;webpack-dev-middleware&#39;);

const app = express();
const config = require(&#39;./webpack.config.js&#39;);
const compiler = webpack(config);

app.use(webpackDevMiddleware(compiler, {
  publicPath: config.output.publicPath
}));

app.listen(3000, function () {
  console.log(&#39;服务已启动，访问地址： localhost:3000!\n&#39;);
});</code></pre>
<p>修改webpack.config.js</p>
<p>设置publicPath: &#39;/&#39;， 启动的服务才能正确访问文件资源。设置publicPath的值会影响index.html内引入js的路径。</p>
<pre><code class="language-json">output: {
    filename: &#39;[name].bundle.js&#39;, // 此时输出的文件名应该也是动态的
    path: path.resolve(__dirname, &#39;dist&#39;),
    publicPath: &#39;/&#39;
}</code></pre>
<p>执行 <code>node server</code> 启动服务。</p>
<p>当然你也可以创建一个npm script。</p>
<pre><code>&quot;server&quot;: &quot;node server&quot;</code></pre><blockquote>
<p>注意： 使用这种方式虽然会实时编译代码， 但是不会实时刷新页面。</p>
<p>因为没有使用热替换。可以使用  <a href="https://github.com/webpack-contrib/webpack-hot-middleware"><code>webpack-hot-middleware</code></a> 。</p>
</blockquote>
<h1 id="9、模块热替换">9、模块热替换</h1>
<p>模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新。</p>
<p>修改webpack.config.js</p>
<pre><code>const path = require(&#39;path&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;).CleanWebpackPlugin 
const webpack = require(&#39;webpack&#39;);

module.exports = {
    mode: &#39;development&#39;, // 设置为&#39;development&#39; 后代码不会压缩
    devtool: &#39;inline-source-map&#39;,
    entry: { // 定义多个入口
        app: &#39;./src/index.js&#39;,
        // component: &#39;./src/component.js&#39; // 避免影响效果， 只输出一个文件
    },
    output: {
        filename: &#39;[name].bundle.js&#39;, // 此时输出的文件名应该也是动态的
        path: path.resolve(__dirname, &#39;dist&#39;),
        publicPath: &#39;/&#39; // 设置的值会影响index.html内引入js的路径
    },
    devServer: {
        port: 8888,
        contentBase: &#39;/dist&#39;,// 告诉服务器从哪里查找文件
        hot: true
    },
    module: {
        rules: [
            {
                test: /\.css$/, // 加载样式文件
                use: [
                    &#39;style-loader&#39;,
                    &#39;css-loader&#39;
                ]
            },
            {
                test: /\.(png|svg|jpg|gif)$/, // 加载图片
                use: [
                    &#39;file-loader&#39;
                ]
            },
            {
                test: /\.(woff|woff2|eot|ttf|otf)$/, // 加载字体
                use: [
                &#39;file-loader&#39;
                ]
            },
            {
                test: /\.(csv|tsv)$/,
                use: [
                &#39;csv-loader&#39;
                ]
            },
            {
                test: /\.xml$/,
                use: [
                &#39;xml-loader&#39;
                ]
            }
        ]
    },
    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            template: &#39;./index.html&#39;
        }),
        new webpack.NamedModulesPlugin(), // 新增
        new webpack.HotModuleReplacementPlugin()// 新增
    ]
}</code></pre><p>修改index.js</p>
<p>如果是全量刷新则会触发onload事件， 以此来判断是否是热替换。</p>
<pre><code>const component = require(&#39;./component.js&#39;)
document.body.appendChild(component());
window.onload = function() {
    console.log(&#39;=====页面全量刷新啦======&#39;)
}
if (module.hot) {
  module.hot.accept(&#39;./component.js&#39;, function() {
    console.log(&#39;更新了 componnet 模块&#39;);
  })
}</code></pre><p>重启服务。 发现修改componet文件及其依赖均不会导致全量刷新， 而修改index.js则会导致全量刷新。</p>
<h1 id="10、tree-shaking">10、tree shaking</h1>
<p><em>tree shaking</em> 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的<a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure">静态结构特性</a>，例如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export"><code>export</code></a>。这个术语和概念实际上是兴起于 ES2015 模块打包工具 <a href="https://github.com/rollup/rollup">rollup</a>。</p>
<h1 id="11、生产环境构建">11、生产环境构建</h1>
<blockquote>
<p><em>开发环境(development)</em>和<em>生产环境(production)</em>的构建目标差异很大。在<em>开发环境</em>中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在<em>生产环境</em>中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong>。</p>
</blockquote>
<p>因此考虑将<code>webpack.config.js</code>拆分为不同的文件：</p>
<p><code>webpack.common.js</code>:   生产环境和开发环境的公共配置。</p>
<p><code>webpack.dev.js</code>: 开发环境配置</p>
<p><code>webpack.prod.js</code>： 生产环境配置</p>
<p><code>webpack.watch.js</code>:  用于测试watch的配置</p>
<p>安装webpack-merge插件, 用于合并配置对象。</p>
<pre><code class="language-shell">npm install --save-dev webpack-merge</code></pre>
<p>安装uglifyjs-webpack-plugin插件， 用于生产环境压缩代码。</p>
<pre><code>npm i -D uglifyjs-webpack-plugin</code></pre><p><code>webpack.common.js</code></p>
<pre><code class="language-js">const path = require(&#39;path&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

module.exports = {
    entry: { // 定义多个入口
        app: &#39;./src/index.js&#39;,
        // component: &#39;./src/component.js&#39;
    },
    output: {
        filename: &#39;[name].bundle.js&#39;, // 此时输出的文件名应该也是动态的
        path: path.resolve(__dirname, &#39;../dist&#39;),
        publicPath: &#39;/&#39; // 设置的值会影响index.html内引入js的路径
    },
    module: {
        rules: [
            {
                test: /\.css$/, // 加载样式文件
                use: [
                    &#39;style-loader&#39;,
                    &#39;css-loader&#39;
                ]
            },
            {
                test: /\.(png|svg|jpg|gif)$/, // 加载图片
                use: [
                    &#39;file-loader&#39;
                ]
            },
            {
                test: /\.(woff|woff2|eot|ttf|otf)$/, // 加载字体
                use: [
                &#39;file-loader&#39;
                ]
            },
            {
                test: /\.(csv|tsv)$/,
                use: [
                &#39;csv-loader&#39;
                ]
            },
            {
                test: /\.xml$/,
                use: [
                &#39;xml-loader&#39;
                ]
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: &#39;./index.html&#39;
        })
    ]
}</code></pre>
<p><code>webpack.dev.js</code></p>
<pre><code class="language-js">const webpack = require(&#39;webpack&#39;);
const webpackMerge = require(&#39;webpack-merge&#39;)
const webpackCommonConfig = require(&#39;./webpack.common&#39;)

console.log(&#39;webpack.dev.js&#39;)
const config = webpackMerge(webpackCommonConfig, 
{
    mode: &#39;development&#39;, // 设置为&#39;development&#39; 后代码不会压缩
    devtool: &#39;inline-source-map&#39;,
    devServer: {
        port: 8888,
        contentBase: &#39;/dist&#39;,// 告诉服务器从哪里查找文件
        hot: true
    },
    plugins: [
        new webpack.NamedModulesPlugin(),
        new webpack.HotModuleReplacementPlugin()
    ]
})
module.exports = config</code></pre>
<p><code>webpack.prod.js</code></p>
<pre><code>const webpackMerge = require(&#39;webpack-merge&#39;)
const webpackCommonConfig = require(&#39;./webpack.common&#39;)
const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;).CleanWebpackPlugin 

console.log(&#39;webpack.prod.js&#39;)
module.exports = webpackMerge(webpackCommonConfig, {
    mode: &#39;production&#39;, // 设置为&#39;development&#39; 后代码不会压缩
    plugins: [
        new CleanWebpackPlugin()
    ]
})</code></pre><blockquote>
<p>现在打包后的css和js混合在了一起， 如何让css单独打包成一个文件呢？</p>
</blockquote>
<p><code>extract-text-webpack-plugin</code></p>
<p>它会将所有的入口 chunk(entry chunks)中引用的 <code>*.css</code>，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 <code>styles.css</code>）当中。 如果你的样式文件大小较大，这会做更快提前加载，*<u>因为 CSS bundle 会跟 JS bundle 并行加载</u>*。</p>
<pre><code>npm install --save-dev extract-text-webpack-plugin</code></pre><p>npm run build 后发现报错， <code>UnhandledPromiseRejectionWarning: Error: Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead</code></p>
<p><strong>原因：</strong>
extract-text-webpack-plugin还不能支持webpack4.0.0以上的版本。</p>
<p>解决办法： </p>
<pre><code>npm install extract-text-webpack-plugin@next -D</code></pre><p>重新打包之后， 发现多了一个styles.css文件。</p>
<h1 id="12、增加静态资源服务器">12、增加静态资源服务器</h1>
<p>在生产环境构建打包后时， 由于设置了publicPath， 将不能直接在本地运行应用， 所以决定通过启动服务来访问。</p>
<p>安装 cross-env</p>
<pre><code>npm install --save-dev cross-env</code></pre><p>创建server/static-server.js</p>
<pre><code>const express = require(&#39;express&#39;)
const path = require(&#39;path&#39;)
const app = express()
console.log(&#39;process.env.publicPath&#39;,process.env.publicPath)
app.use(express.static(path.resolve(__dirname, &#39;../dist&#39;)))

app.listen(8001, () =&gt; {
    console.log(&#39;服务已启动，访问地址： localhost:8001!\n&#39;);
})
</code></pre><p>修改package.json</p>
<pre><code>&quot;test:prod&quot;: &quot;cross-env publicPath=aaa  npm run build &amp;&amp; node ./server/static-server&quot;</code></pre><p>执行 npm   run  test:prod  将会先打包然后启动一个静态资源服务。</p>
<h1 id="13、代码分离">13、代码分离</h1>
<p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>
<p>有三种常用的代码分离方法：</p>
<ul>
<li>入口起点：使用 <a href="https://www.webpackjs.com/configuration/entry-context"><code>entry</code></a> 配置手动地分离代码。</li>
<li>防止重复：使用 <a href="https://www.webpackjs.com/plugins/commons-chunk-plugin"><code>CommonsChunkPlugin</code></a> 去重和分离 chunk。</li>
<li>动态导入：通过模块的内联函数调用来分离代码。</li>
</ul>
<h2 id="131、入口起点">13.1、入口起点</h2>
<p>通过设置多个入口打包成多个文件来达到代码分离的效果。</p>
<pre><code>  entry: {
    index: &#39;./src/index.js&#39;,
    another: &#39;./src/another-module.js&#39;
  },</code></pre><p>这种方法存在一些问题:</p>
<ul>
<li>如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中。</li>
<li>这种方法不够灵活，并且不能将核心应用程序逻辑进行动态拆分代码。</li>
</ul>
<h2 id="132、防止重复">13.2、防止重复</h2>
<p>起初，chunks(代码块)和导入他们中的模块通过webpack内部的父子关系图连接.在webpack3中，通过CommonsChunkPlugin来避免他们之间的依赖重复。而在webpack4中CommonsChunkPlugin被移除，取而代之的是 optimization.splitChunks 和 optimization.runtimeChunk 配置项，下面展示它们将如何工作。</p>
<p>webpack将根据以下条件自动拆分代码块：</p>
<ul>
<li>会被共享的代码块或者 node_mudules 文件夹中的代码块</li>
<li>体积大于30KB的代码块（在gz压缩前）</li>
<li>按需加载代码块时的并行请求数量不超过5个</li>
<li>加载初始页面时的并行请求数量不超过3个</li>
</ul>
<blockquote>
<p>SplitChunksPlugin的默认配置</p>
</blockquote>
<pre><code>   splitChunks: {
        chunks: &quot;async&quot;,
        minSize: 30000, // 模块的最小体积
        minChunks: 1, // 模块的最小被引用次数
        maxAsyncRequests: 5, // 按需加载的最大并行请求数
        maxInitialRequests: 3, // 一个入口最大并行请求数
        automaticNameDelimiter: &#39;~&#39;, // 文件名的连接符
        name: true,
        cacheGroups: { // 缓存组
            vendors: {
                test: /[\\/]node_modules[\\/]/,
                priority: -10
            },
            default: {
                minChunks: 2,
                priority: -20,
                reuseExistingChunk: true
            }
        }
    }</code></pre><p>缓存组因该是SplitChunksPlugin中最有趣的功能了。在默认设置中，会将 node_mudules 文件夹中的模块打包进一个叫 vendors的bundle中，所有引用超过两次的模块分配到 default bundle 中。更可以通过 priority 来设置优先级。</p>
<h2 id="133、动态导入">13.3、动态导入</h2>
<p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 <a href="https://github.com/tc39/proposal-dynamic-import">ECMAScript 提案</a> 的 <a href="https://www.webpackjs.com/api/module-methods#import-"><code>import()</code> 语法</a>。第二种，则是使用 webpack 特定的 <a href="https://www.webpackjs.com/api/module-methods#require-ensure"><code>require.ensure</code></a>。</p>
<blockquote>
<p>注意/* webpackChunkName: &quot;lodashName&quot; */是必不可少的。lodashName是打包输出后的文件名。</p>
</blockquote>
<pre><code>import(/* webpackChunkName: &quot;lodashName&quot; */ &#39;lodash&#39;)</code></pre><blockquote>
<p>动态导入实现懒加载</p>
</blockquote>
<h1 id="14、缓存">14、缓存</h1>
<p>浏览器使用一种名为 <a href="https://searchstorage.techtarget.com/definition/cache">缓存</a> 的技术。可以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。</p>
<h2 id="141、输出文件的文件名">14.1、输出文件的文件名</h2>
<p>通过使用 <code>output.filename</code> 进行<a href="https://www.webpackjs.com/configuration/output#output-filename">文件名替换</a>，可以确保浏览器获取到修改后的文件。<code>[hash]</code> 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 <code>[chunkhash]</code> 替换，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。</p>
<pre><code>output: {
    filename: &#39;[name].[chunkhash].js&#39;, // 此时输出的文件名应该也是动态的
    chunkFilename: &#39;[name].[chunkhash].js&#39;, // 在代码切割时，它决定非入口 chunk 的名称
    path: path.resolve(__dirname, &#39;../dist&#39;),
    publicPath: &#39;/&#39; // 设置的值会影响index.html内引入js的径
}</code></pre><p>输出时使用hash 或 chunkhash,使用hash时每个文件的hash值都一样， 使用chunkhash时，每个文件都有自己的hash值。</p>
<h2 id="142、提取样板代码">14.2、提取样板代码</h2>
<p>样板(boilerplate)，指 webpack 运行时的引导代码，特别是 runtime 和 manifest。</p>
<p>webpack已废弃<a href="https://www.webpackjs.com/plugins/commons-chunk-plugin"><code>CommonsChunkPlugin</code></a> 。</p>
<pre><code>optimization: {
    runtimeChunk: {
        name: &quot;manifest&quot;
    }
}</code></pre><h2 id="143、模块标识符">14.3、模块标识符</h2>
<p>在每次npm run build后所有文件的hash都会变化。这是因为每个 <a href="https://www.webpackjs.com/api/module-variables#module-id-commonjs-"><code>module.id</code></a> 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。因此，简要概括：</p>
<ul>
<li><code>main</code> bundle 会随着自身的新增内容的修改，而发生变化（也就是我们这里的app.js）。</li>
<li><code>vendor</code> bundle 会随着自身的 <code>module.id</code> 的修改，而发生变化。</li>
<li><code>manifest</code> bundle 会因为当前包含一个新模块的引用，而发生变化。</li>
</ul>
<p>第一个和最后一个都是符合预期的行为 -- 而 <code>vendor</code> 的 hash 发生变化是我们要修复的。幸运的是，可以使用两个插件来解决这个问题。第一个插件是 <a href="https://www.webpackjs.com/plugins/named-modules-plugin"><code>NamedModulesPlugin</code></a>，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 <a href="https://www.webpackjs.com/plugins/hashed-module-ids-plugin"><code>HashedModuleIdsPlugin</code></a>，推荐用于生产环境构建：</p>
<pre><code>new webpack.HashedModuleIdsPlugin()</code></pre><p>使用插件后你会发现每次打包后hash不会再变化。</p>
<h1 id="15、创建-library">15、创建 library</h1>
<p>除了打包应用程序代码，webpack 还可以用于打包 JavaScript library（生成自己的可用于浏览器使用的模块，比如umd）。</p>
<h1 id="16、shimming">16、shimming</h1>
<p><code>webpack</code> 编译器(compiler)能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些第三方的库(library)可能会引用一些全局依赖（例如 <code>jQuery</code> 中的 <code>$</code>）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 <em>shimming</em> 发挥作用的地方。</p>
<h2 id="161、shimming-全局变量">16.1、shimming 全局变量</h2>
<p>修改webpack配置：</p>
<pre><code>new webpack.ProvidePlugin({
    _: &#39;lodash&#39;
})</code></pre><p>安装 lodash</p>
<pre><code>npm i lodash -D</code></pre><blockquote>
<p>配置 _  为全局变量后， 就可以在任何地方使用 _  了。</p>
</blockquote>
<p>出于演示的目的，让我们把这个模块作为我们应用程序中的一个全局变量。要实现这些，我们需要使用 <code>ProvidePlugin</code> 插件。使用 <a href="https://www.webpackjs.com/plugins/provide-plugin"><code>ProvidePlugin</code></a> 后，能够在通过 webpack 编译的每个模块中，通过访问一个变量来获取到 package 包。如果 webpack 知道这个变量在某个模块中被使用了，那么 webpack 将在最终 bundle 中引入我们给定的 package。</p>
<p>本质上，我们所做的，就是告诉 webpack……</p>
<blockquote>
<p>如果你遇到了至少一处用到 <code>lodash</code> 变量的模块实例，那请你将 <code>lodash</code> package 包引入进来，并将其提供给需要用到它的模块。</p>
</blockquote>
<p>但是在使用lodash时可能只是使用了某一部分导出，因此可以做按需打包的处理。这样就能很好的与 <a href="https://www.webpackjs.com/guides/tree-shaking">tree shaking</a> 配合，将 <code>lodash</code> 库中的其他没用到的部分去除。</p>
<h2 id="162、细粒度-shimming">16.2、细粒度 shimming</h2>
<h2 id="163、全局-exports">16.3、全局 exports</h2>
<h2 id="164、加载-polyfills">16.4、加载 polyfills</h2>
<h1 id="17、渐进式网络应用程序">17、渐进式网络应用程序</h1>
<p>渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在<strong>离线(offline)</strong>时应用程序能够继续运行功能。这是通过使用名为 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">Service Workers</a> 的网络技术来实现的。</p>
<p>添加 workbox-webpack-plugin 插件，并调整 <code>webpack</code>配置 文件：</p>
<pre><code>npm install workbox-webpack-plugin --save-dev</code></pre><pre><code>new WorkboxPlugin.GenerateSW({
    // 这些选项帮助 ServiceWorkers 快速启用
    // 不允许遗留任何“旧的” ServiceWorkers
    clientsClaim: true,
    skipWaiting: true
})</code></pre><p>index.js</p>
<pre><code>/**
 * 注册我们的 Service Worker
 * 运行 npm run test:prod， 访问8001， 关闭服务器刷新页面，即可看到效果。
 */
if (&#39;serviceWorker&#39; in navigator) {
  window.addEventListener(&#39;load&#39;, () =&gt; {
    navigator.serviceWorker.register(&#39;/service-worker.js&#39;).then(registration =&gt; {
      console.log(&#39;SW registered: &#39;, registration);
    }).catch(registrationError =&gt; {
      console.log(&#39;SW registration failed: &#39;, registrationError);
    });
  });
}</code></pre>
            </article> 
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>  
          </body>
      </html>