# 参考文档
https://tech.meituan.com/2018/09/27/fe-security.html

# XSS攻击的介绍
> 什么是XSS?

`Cross-Site Scripting（跨站脚本攻击）简称 XSS`，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。*为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。*

> XSS的本质
*XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。*

> 危害
由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。
在部分情况下，由于输入的限制，注入的恶意脚本比较短。但可以通过引入外部的脚本，并由浏览器执行，来完成比较复杂的攻击策略。


# XSS 漏洞的发生和修复
1. 通常页面中包含的用户输入内容都在固定的容器或者属性内，以文本的形式展示，攻击者利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段。
    - 告诉浏览器用户输入的这段内容是文本就可以了，对输入内容进行过滤和HTML转义。

2. 特殊的 HTML 属性、JavaScript API。
    - 对于链接跳转，如 `<a href="xxx" 或 location.href="xxx"`，要检验其内容，禁止以 `javascript: `开头的链接，和其他非法的 `scheme`。


# XSS有哪些注入的方法？
1. 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
2. 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
3. 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
4. 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。
5. 在 onload、onerror、onclick 等事件中，注入不受控制代码。
6. 在 style 属性和标签中，包含类似 background-image:url("javascript:..."); 的代码（新版本浏览器已经可以防范）。
7. 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。

> 总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。


# XSS分类
根据攻击的来源，XSS 攻击可分为`存储型`、`反射型`和 `DOM` 型三种。

### 存储型 XSS
存储型 XSS 的攻击步骤：
1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
5. 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。


### 反射型 XSS
反射型 XSS 的攻击步骤：
1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

> 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。
反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。
由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。
POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。


### DOM 型 XSS
DOM 型 XSS 的攻击步骤：
1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

> DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。


# XSS攻击的两大要素：
1. 页面被注入了恶意的代码。
2. 浏览器执行恶意代码。

> 针对第一个要素：我们是否能够在用户输入的过程，过滤掉用户输入的恶意代码呢？

### 输入过滤
1. 在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？
答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。

2. 那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？
我们举一个例子，一个正常的用户输入了 `5 < 7` 这个内容，在写入数据库前，被转义，变成了 `5 &lt; 7`。


3. *问题是：在提交阶段，我们并不确定内容要输出到哪里?*
    1. 用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码`( 5 &lt; 7 )`。
    2. 在前端中，不同的位置所需的编码也不同。
        - 当 5 &lt; 7 作为 HTML 拼接页面时，可以正常显示：
            ```html
            <div title="comment">5 &lt; 7</div>
            ```
        - 当 `5 &lt; 7` 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。

> 总结
- 输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题, 在防范 XSS 攻击时应避免此类方法。
- 当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。


> 既然输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。

### 防止浏览器执行恶意代码
1. 防止 HTML 中出现注入。
2. 防止 JavaScript 执行时，执行恶意代码。


> 预防存储型和反射型 XSS 攻击
预防这两种漏洞，有两种常见做法：
1. 改成纯前端渲染，把代码和数据分隔开。
    - 纯前端渲染的过程：
        1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
        2. 然后浏览器执行 HTML 中的 JavaScript。
        3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。
2. 对 HTML 做充分转义。
    如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。

> 预防 DOM 型 XSS 攻击
1. `DOM 型 XSS 攻击`，实际上就是网站前端` JavaScript `代码本身不够严谨，把不可信的数据当作代码执行了。在使用` .innerHTML、.outerHTML、document.write() `时要特别小心，不要把不可信的数据作为` HTML `插到页面上，而应尽量使用` .textContent`、`.setAttribute() `等。

2. 如果用` Vue/React `技术栈，并且不使用` v-html/dangerouslySetInnerHTML `功能，就在前端` render `阶段避免` innerHTML、outerHTML `的` XSS `隐患。

3. `DOM `中的内联事件监听器，如` location、onclick、onerror、onload、onmouseover `等，`<a> `标签的 `href` 属性，`JavaScript` 的 `eval()、setTimeout()、setInterval() `等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。


# 其他 XSS 防范措施

### Content Security Policy
严格的 CSP 在 XSS 的防范中可以起到以下的作用：
- 禁止加载外域代码，防止复杂的攻击逻辑。
- 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
- 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
- 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
- 合理使用上报可以及时发现 XSS，利于尽快修复问题。

### 输入内容长度控制
对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。

### 其他安全措施
1. HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
2. 验证码：防止脚本冒充用户提交危险操作。


# XSS的检测
1. 手动检测
2. 了手动检测之外，还可以使用自动扫描工具寻找 XSS 漏洞，例如 Arachni、Mozilla HTTP Observatory、w3af 等。


# 思考
> XSS 防范是后端 RD 的责任，后端 RD 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。
不正确。因为： 
*防范存储型和反射型 XSS 是后端 RD 的责任。而 DOM 型 XSS 攻击不发生在后端，是前端 RD 的责任。防范 XSS 是需要后端 RD 和前端 RD 共同参与的系统工程。 转义应该在输出 HTML 时进行，而不是在提交用户输入时。*

> 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。
不正确。 *不同的上下文，如 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等，所需要的转义规则不一致。 业务 RD 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。*

> 虽然很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：
1. 利用模板引擎 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>； 在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。

2. 避免内联事件 尽量不要使用 onLoad="onload('{{data}}')"、onClick="go('{{action}}')" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。

3. 免拼接 HTML 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。

4. 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。

5. 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。

6. 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。



# 课后作业：XSS 攻击小游戏











