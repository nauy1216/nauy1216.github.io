<!DOCTYPE html>
      <html>
          <head>
          <meta charset="utf-8" >
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <title>vue.md</title>
          <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github-gist.min.css" rel="stylesheet">  
          <style>
              .markdown-body {
                  box-sizing: border-box;
                  min-width: 200px;
                  max-width: 980px;
                  margin: 0 auto;
                  padding: 45px;
              }
              .markdown-body img {
                  box-sizing: border-box !important;
                  margin:10px 0 10px 2%;
                  padding: 20px;
                  width: 96%;
                  border-radius: 4px;
                  box-shadow: 0 0 6px 0px #999;
              }
              @media (max-width: 767px) {
                  .markdown-body {
                      padding: 15px;
                  }
              }
              @font-face{font-family:octicons-link;src:url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff')}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body .anchor{float:left;line-height:1;margin-left:-20px;padding-right:4px}.markdown-body .anchor:focus{outline:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1b1f23;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;color:#24292e;line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .pl-c{color:#6a737d}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#005cc5}.markdown-body .pl-e,.markdown-body .pl-en{color:#6f42c1}.markdown-body .pl-s .pl-s1,.markdown-body .pl-smi{color:#24292e}.markdown-body .pl-ent{color:#22863a}.markdown-body .pl-k{color:#d73a49}.markdown-body .pl-pds,.markdown-body .pl-s,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sra,.markdown-body .pl-sr .pl-sre{color:#032f62}.markdown-body .pl-smw,.markdown-body .pl-v{color:#e36209}.markdown-body .pl-bu{color:#b31d28}.markdown-body .pl-ii{background-color:#b31d28;color:#fafbfc}.markdown-body .pl-c2{background-color:#d73a49;color:#fafbfc}.markdown-body .pl-c2:before{content:"^M"}.markdown-body .pl-sr .pl-cce{color:#22863a;font-weight:700}.markdown-body .pl-ml{color:#735c0f}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{color:#005cc5;font-weight:700}.markdown-body .pl-mi{color:#24292e;font-style:italic}.markdown-body .pl-mb{color:#24292e;font-weight:700}.markdown-body .pl-md{background-color:#ffeef0;color:#b31d28}.markdown-body .pl-mi1{background-color:#f0fff4;color:#22863a}.markdown-body .pl-mc{background-color:#ffebda;color:#e36209}.markdown-body .pl-mi2{background-color:#005cc5;color:#f6f8fa}.markdown-body .pl-mdr{color:#6f42c1;font-weight:700}.markdown-body .pl-ba{color:#586069}.markdown-body .pl-sg{color:#959da5}.markdown-body .pl-corl{color:#032f62;text-decoration:underline}.markdown-body details{display:block}.markdown-body summary{display:list-item}.markdown-body a{background-color:transparent}.markdown-body a:active,.markdown-body a:hover{outline-width:0}.markdown-body strong{font-weight:inherit;font-weight:bolder}.markdown-body h1{font-size:2em;margin:.67em 0}.markdown-body img{border-style:none}.markdown-body code,.markdown-body kbd,.markdown-body pre{font-family:monospace,monospace;font-size:1em}.markdown-body hr{box-sizing:content-box;height:0;overflow:visible}.markdown-body input{font:inherit;margin:0}.markdown-body input{overflow:visible}.markdown-body [type=checkbox]{box-sizing:border-box;padding:0}.markdown-body *{box-sizing:border-box}.markdown-body input{font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body a{color:#0366d6;text-decoration:none}.markdown-body a:hover{text-decoration:underline}.markdown-body strong{font-weight:600}.markdown-body hr{background:0 0;border:0;border-bottom:1px solid #dfe2e5;height:0;margin:15px 0;overflow:hidden}.markdown-body hr:before{content:"";display:table}.markdown-body hr:after{clear:both;content:"";display:table}.markdown-body table{border-collapse:collapse;border-spacing:0}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-bottom:0;margin-top:0}.markdown-body h1{font-size:32px}.markdown-body h1,.markdown-body h2{font-weight:600}.markdown-body h2{font-size:24px}.markdown-body h3{font-size:20px}.markdown-body h3,.markdown-body h4{font-weight:600}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:14px}.markdown-body h5,.markdown-body h6{font-weight:600}.markdown-body h6{font-size:12px}.markdown-body p{margin-bottom:10px;margin-top:0}.markdown-body blockquote{margin:0}.markdown-body ol,.markdown-body ul{margin-bottom:0;margin-top:0;padding-left:0}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ol ol ol,.markdown-body ol ul ol,.markdown-body ul ol ol,.markdown-body ul ul ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body code,.markdown-body pre{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px}.markdown-body pre{margin-bottom:0;margin-top:0}.markdown-body input::-webkit-inner-spin-button,.markdown-body input::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}.markdown-body .border{border:1px solid #e1e4e8!important}.markdown-body .border-0{border:0!important}.markdown-body .border-bottom{border-bottom:1px solid #e1e4e8!important}.markdown-body .rounded-1{border-radius:3px!important}.markdown-body .bg-white{background-color:#fff!important}.markdown-body .bg-gray-light{background-color:#fafbfc!important}.markdown-body .text-gray-light{color:#6a737d!important}.markdown-body .mb-0{margin-bottom:0!important}.markdown-body .my-2{margin-bottom:8px!important;margin-top:8px!important}.markdown-body .pl-0{padding-left:0!important}.markdown-body .py-0{padding-bottom:0!important;padding-top:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .py-2{padding-bottom:8px!important;padding-top:8px!important}.markdown-body .pl-3,.markdown-body .px-3{padding-left:16px!important}.markdown-body .px-3{padding-right:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body .f6{font-size:12px!important}.markdown-body .lh-condensed{line-height:1.25!important}.markdown-body .text-bold{font-weight:600!important}.markdown-body:before{content:"";display:table}.markdown-body:after{clear:both;content:"";display:table}.markdown-body>:first-child{margin-top:0!important}.markdown-body>:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body blockquote,.markdown-body dl,.markdown-body ol,.markdown-body p,.markdown-body pre,.markdown-body table,.markdown-body ul{margin-bottom:16px;margin-top:0}.markdown-body hr{background-color:#e1e4e8;border:0;height:.25em;margin:24px 0;padding:0}.markdown-body blockquote{border-left:.25em solid #dfe2e5;color:#6a737d;padding:0 1em}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body kbd{background-color:#fafbfc;border:1px solid #c6cbd1;border-bottom-color:#959da5;border-radius:3px;box-shadow:inset 0 -1px 0 #959da5;color:#444d56;display:inline-block;font-size:11px;line-height:10px;padding:3px 5px;vertical-align:middle}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{font-weight:600;line-height:1.25;margin-bottom:16px;margin-top:24px}.markdown-body h1{font-size:2em}.markdown-body h1,.markdown-body h2{border-bottom:1px solid #eaecef;padding-bottom:.3em}.markdown-body h2{font-size:1.5em}.markdown-body h3{font-size:1.25em}.markdown-body h4{font-size:1em}.markdown-body h5{font-size:.875em}.markdown-body h6{color:#6a737d;font-size:.85em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-bottom:0;margin-top:0}.markdown-body li{word-wrap:break-all}.markdown-body li>p{margin-top:16px}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{font-size:1em;font-style:italic;font-weight:600;margin-top:16px;padding:0}.markdown-body dl dd{margin-bottom:16px;padding:0 16px}.markdown-body table{display:block;overflow:auto;width:100%}.markdown-body table th{font-weight:600}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:6px 13px}.markdown-body table tr{background-color:#fff;border-top:1px solid #c6cbd1}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body img{background-color:#fff;box-sizing:content-box;max-width:100%}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body code{background-color:rgba(27,31,35,.05);border-radius:3px;font-size:85%;margin:0;padding:.2em .4em}.markdown-body pre{word-wrap:normal}.markdown-body pre>code{background:0 0;border:0;font-size:100%;margin:0;padding:0;white-space:pre;word-break:normal}.markdown-body .highlight{margin-bottom:16px}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{background-color:#f6f8fa;border-radius:3px;font-size:85%;line-height:1.45;overflow:auto;padding:16px}.markdown-body pre code{background-color:transparent;border:0;display:inline;line-height:inherit;margin:0;max-width:auto;overflow:visible;padding:0;word-wrap:normal}.markdown-body .commit-tease-sha{color:#444d56;display:inline-block;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:90%}.markdown-body .blob-wrapper{border-bottom-left-radius:3px;border-bottom-right-radius:3px;overflow-x:auto;overflow-y:hidden}.markdown-body .blob-wrapper-embedded{max-height:240px;overflow-y:auto}.markdown-body .blob-num{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;color:rgba(27,31,35,.3);cursor:pointer;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;line-height:20px;min-width:50px;padding-left:10px;padding-right:10px;text-align:right;user-select:none;vertical-align:top;white-space:nowrap;width:1%}.markdown-body .blob-num:hover{color:rgba(27,31,35,.6)}.markdown-body .blob-num:before{content:attr(data-line-number)}.markdown-body .blob-code{line-height:20px;padding-left:10px;padding-right:10px;position:relative;vertical-align:top}.markdown-body .blob-code-inner{color:#24292e;font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:12px;overflow:visible;white-space:pre;word-wrap:normal}.markdown-body .pl-token.active,.markdown-body .pl-token:hover{background:#ffea7f;cursor:pointer}.markdown-body kbd{background-color:#fafbfc;border:1px solid #d1d5da;border-bottom-color:#c6cbd1;border-radius:3px;box-shadow:inset 0 -1px 0 #c6cbd1;color:#444d56;display:inline-block;font:11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:10px;padding:3px 5px;vertical-align:middle}.markdown-body :checked+.radio-label{border-color:#0366d6;position:relative;z-index:1}.markdown-body .tab-size[data-tab-size="1"]{-moz-tab-size:1;tab-size:1}.markdown-body .tab-size[data-tab-size="2"]{-moz-tab-size:2;tab-size:2}.markdown-body .tab-size[data-tab-size="3"]{-moz-tab-size:3;tab-size:3}.markdown-body .tab-size[data-tab-size="4"]{-moz-tab-size:4;tab-size:4}.markdown-body .tab-size[data-tab-size="5"]{-moz-tab-size:5;tab-size:5}.markdown-body .tab-size[data-tab-size="6"]{-moz-tab-size:6;tab-size:6}.markdown-body .tab-size[data-tab-size="7"]{-moz-tab-size:7;tab-size:7}.markdown-body .tab-size[data-tab-size="8"]{-moz-tab-size:8;tab-size:8}.markdown-body .tab-size[data-tab-size="9"]{-moz-tab-size:9;tab-size:9}.markdown-body .tab-size[data-tab-size="10"]{-moz-tab-size:10;tab-size:10}.markdown-body .tab-size[data-tab-size="11"]{-moz-tab-size:11;tab-size:11}.markdown-body .tab-size[data-tab-size="12"]{-moz-tab-size:12;tab-size:12}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item+.task-list-item{margin-top:3px}.markdown-body .task-list-item input{margin:0 .2em .25em -1.6em;vertical-align:middle}.markdown-body hr{border-bottom-color:#eee}.markdown-body .pl-0{padding-left:0!important}.markdown-body .pl-1{padding-left:4px!important}.markdown-body .pl-2{padding-left:8px!important}.markdown-body .pl-3{padding-left:16px!important}.markdown-body .pl-4{padding-left:24px!important}.markdown-body .pl-5{padding-left:32px!important}.markdown-body .pl-6{padding-left:40px!important}.markdown-body .pl-7{padding-left:48px!important}.markdown-body .pl-8{padding-left:64px!important}.markdown-body .pl-9{padding-left:80px!important}.markdown-body .pl-10{padding-left:96px!important}.markdown-body .pl-11{padding-left:112px!important}.markdown-body .pl-12{padding-left:128px!important}
/*# sourceMappingURL=github-markdown.min.css.map */
          </style>
          <script>
              window.onload = function() {
                hljs.initHighlighting()
              }
          </script>
          </head>
          <body>
            <article class="markdown-body">
                <h1 id="解决rollup-plugin-alias在window报错的问题">解决rollup-plugin-alias在window报错的问题</h1>
<p>直接将rollup-plugin-alias.js全部内容替换为下面的代码：</p>
<pre><code class="language-js">const path = require(&#39;path&#39;) ;
const fs = require(&#39;fs&#39;) ;

// Helper functions
const noop = () =&gt; null;
const startsWith = (needle, haystack) =&gt; ! haystack.indexOf(needle);
const endsWith = (needle, haystack) =&gt; haystack.slice(-needle.length) === needle;
const isFilePath = id =&gt; /(^\.?\/)|(^[a-zA-Z]\:(\\|\/))/.test(id);
const exists = uri =&gt; {
  try {
    return fs.statSync(uri).isFile();
  } catch (e) {
    return false;
  }
};

module.exports =  function alias(options = {}) {
  const hasResolve = Array.isArray(options.resolve);
  const resolve = hasResolve ? options.resolve : [&#39;.js&#39;];
  const aliasKeys = hasResolve ?
                      Object.keys(options).filter(k =&gt; k !== &#39;resolve&#39;) : Object.keys(options);

  // No aliases?
  if (!aliasKeys.length) {
    return {
      resolveId: noop,
    };
  }

  return {
    resolveId(importee, importer) {
      // First match is supposed to be the correct one
      const toReplace = aliasKeys.find(key =&gt; startsWith(key, importee));

      if (!toReplace) {
        return null;
      }

      const entry = options[toReplace];

      const updatedId = importee.replace(toReplace, entry);

      if (isFilePath(updatedId)) {
        const directory = path.dirname(importer);

        // Resolve file names
        const filePath = path.resolve(directory, updatedId);
        const match = resolve.map(ext =&gt; `${filePath}${ext}`)
                            .find(exists);

        if (match) {
          return match;
        }

        // To keep the previous behaviour we simply return the file path
        // with extension
        if (endsWith(&#39;.js&#39;, filePath)) {
          return filePath;
        }

        return filePath + &#39;.js&#39;;
      }

      return updatedId;
    },
  };
}</code></pre>
<h1 id="从npm-run-dev开始">从<code>npm run dev</code>开始</h1>
<p>项目使用的打包工具是rollup, <code>scripts/config.js</code>是rollup的配置文件。</p>
<pre><code>rollup -w -c scripts/config.js --environment TARGET:web-full-dev</code></pre><p>很容易找到web-full-dev对应的配置。我们这里学习的是runtime + compiler版本的vue。</p>
<pre><code class="language-js">  // Runtime+compiler development build (Browser)
  &#39;web-full-dev&#39;: {
    entry: resolve(&#39;web/entry-runtime-with-compiler.js&#39;),
    dest: resolve(&#39;dist/vue.js&#39;),
    format: &#39;umd&#39;,
    env: &#39;development&#39;,
    alias: { he: &#39;./entity-decoder&#39; },
    banner
  },</code></pre>
<p>由此可知， <code>Runtime+compiler development build (Browser)</code>版本的入口是   <code>web/entry-runtime-with-compiler.js</code>。</p>
<h1 id="webentry-runtime-with-compilerjs"><code>web/entry-runtime-with-compiler.js</code></h1>
<p>因为我们看的是runtime + compiler 的版本， 所以我们能够看到runtime的入口：</p>
<pre><code class="language-js">import Vue from &#39;./runtime/index&#39;</code></pre>
<p>以及compiler的入口：</p>
<pre><code class="language-js">import { compileToFunctions } from &#39;./compiler/index&#39;</code></pre>
<h1 id="runtimeindexjs">/runtime/index.js</h1>
<p>主要做了以下几件事情：</p>
<p>1、注册<code>v-model</code>和<code>v-show</code>指令</p>
<pre><code class="language-js">extend(Vue.options.directives, platformDirectives)</code></pre>
<p>2、注册<code>Transition</code>和<code>TransitionGroup</code>组件</p>
<pre><code class="language-js">extend(Vue.options.components, platformComponents)</code></pre>
<p>3、安装patch方法</p>
<pre><code>// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop</code></pre><p>4、定义<code>$mount</code>方法， 该方法会在<code>web/entry-runtime-with-compiler.js</code>被重写，具体原因后面再说。</p>
<pre><code class="language-js">Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}</code></pre>
<blockquote>
<p>你可能已经注意到了，在该文件里并没有定义Vue构造方法的地方。</p>
</blockquote>
<p>Vue构造函数是从这里引入的。</p>
<pre><code class="language-js">import Vue from &#39;core/index&#39;</code></pre>
<h1 id="coreindexjs">core/index.js</h1>
<p>定义Vue构造函数的地方：</p>
<p>1、在构造函数内部只调用了_init()方法， 该方法是在initMixin里面定义的。</p>
<p>2、通过mixin的方式给构造方法Vue的原型上添加不同的方法。</p>
<pre><code class="language-js">function Vue (options) {
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;
    !(this instanceof Vue)
  ) {
    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)</code></pre>
<p>在core/index.js里面有这一行代码， 主要是给Vue构造函数增加一些静态方法， 比如Vue.use()、Vue.nextTick()等。</p>
<pre><code class="language-js">initGlobalAPI(Vue)</code></pre>
<blockquote>
<p>core/index.js主要做了三件事：</p>
<p>1、定义Vue构造函数。</p>
<p>2、构造函数Vue添加原型方法。</p>
<p>3、构造函数Vue添加静态方法。</p>
</blockquote>
<h1 id="initmixin">initMixin</h1>
<p>initMixin方法的伪代码如下：</p>
<pre><code class="language-js">export function initMixin (Vue: Class&lt;Component&gt;) {
  Vue.prototype._init = function (options?: Object) {
      // 1、合并options得到最终的$options
      // 2、initLifecycle(vm)
    // 3、initEvents(vm)
    // 4、initRender(vm)

    // 5、callHook(vm, &#39;beforeCreate&#39;)
    // 执行beforeCreate钩子， 因为在执行beforeCreate时并没有初始化组件的数据状态，
    // 因此在beforeCreate里面是不能访问到data、props、inject的数据的。


    // 6、initInjections(vm) // resolve injections before data/props
    // 获取从父组件或者更高级的父组件通过provide注入到子孙组件的数据

    // 7、initState(vm)
    // 初始化 props、data、computed

    // 8、initProvide(vm) // resolve provide after data/props
    // 初始化要注入到子孙组件的数据

    // 9、callHook(vm, &#39;created&#39;)
    // 执行created钩子， 此时能够访问到组件的数据

    // 10、 如果el存在的话， 将会编译模板并且将通关过patch的方式将生成的DOM元素挂载到页面上
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}</code></pre>
<h1 id="statemixin">stateMixin</h1>
<pre><code class="language-js">export function stateMixin (Vue: Class&lt;Component&gt;) {
  // 在原型上定义$data和$props属性， 并不是在实例上定义的。
  Object.defineProperty(Vue.prototype, &#39;$data&#39;, dataDef)
  Object.defineProperty(Vue.prototype, &#39;$props&#39;, propsDef)

  Vue.prototype.$set = set
  Vue.prototype.$delete = del

  Vue.prototype.$watch
}</code></pre>
<h1 id="eventsmixin">eventsMixin</h1>
<pre><code class="language-js">function eventsMixin (Vue: Class&lt;Component&gt;) {
    Vue.prototype.$on
    Vue.prototype.$once
    Vue.prototype.$off
    Vue.prototype.$emit
}</code></pre>
<p>这里的逻辑比较简单， 只是实现了一套事件模型。</p>
<h1 id="lifecyclemixin">lifecycleMixin</h1>
<pre><code class="language-js">function lifecycleMixin (Vue: Class&lt;Component&gt;) {
    // vnode的patch逻辑是在这里执行的
    Vue.prototype._update

    // 内部调用了renderWatch的update方法
    Vue.prototype.$forceUpdate

    // 
    Vue.prototype.$destroy = function() {
        // 执行beforeDestroy钩子
        callHook(vm, &#39;beforeDestroy&#39;)

        // 将当前元素从parent.$children中删除
         remove(parent.$children, vm)

        // 销毁所有的watcher，包括renderWatch、computedWatch、useWatch
        watcher.teardown()

        // 通过patch(vnode, null)方式将当前组件的dom元素从页面上移除

        // 执行destroyed钩子
        callHook(vm, &#39;destroyed&#39;)

        // 注销所有的事件
        vm.$off()

        // 将当前组件对象对父组件对象的引用删除
        // 因为浏览器是通过引用计数的方式来判断是否要销毁对象的
        // 当一个对象的引用计数为0时将会被销毁
        vm.$vnode.parent = null
    }
}</code></pre>
<h1 id="rendermixin">renderMixin</h1>
<pre><code class="language-js">function renderMixin (Vue: Class&lt;Component&gt;) {
    // 增加一些生成vnode的辅助函数， 在组件render方法内部使用
    installRenderHelpers(Vue.prototype)

    //
    Vue.prototype.$nextTick

    Vue.prototype._render = function (): VNode {
        // 获取组件的render方法
        const { render, _parentVnode } = vm.$options

        // 执行render方法生成vnode对象
        vnode = render.call(vm._renderProxy, vm.$createElement)

        // 
        return vnode
    }
}</code></pre>
<h1 id="initglobalapi">initGlobalAPI</h1>
<pre><code class="language-js">  Vue.set = set
  Vue.delete = del
  Vue.nextTick = nextTick

  Vue.observable

  Vue.options
  Vue.use
  Vue.mixin
  Vue.extend

  Vue.component
  Vue.directive
  Vue.filter</code></pre>
<p>到此为止， 我们已经很清楚的知道了Vue构造函数是怎样定义的， 明白了Vue的原型方法及原型属性，静态方法及静态属性。从简单的定义Vue构造方法到最终生成一个复杂的Vue‘类’有了一个大致的了解。</p>
<h1 id="从一个简单的例子开始">从一个简单的例子开始</h1>
<p>代码：</p>
<pre><code class="language-js">new Vue({
    el: &#39;#app&#39;,
    data() {
        return {
            message: [
                &#39;hello&#39;,
                {
                    a: &#39;a&#39;
                }
            ]
        }
    },
    computed: {
        msg() {
            return this.message
        }
    },
    methods: {
        handleClick() {
            this.message = Math.random()
        }
    },
    render(h) {
        return h(&#39;h1&#39;, {
            attrs: {
                class: &#39;hello&#39;
            },
            on: {
                click: this.handleClick
            }
        }, this.msg)
    }
})</code></pre>
<p>在构造方法内打上断点进入到this._init方法。</p>
<h2 id="合并options">合并options</h2>
<p>通过不同的合并策略合并options得到最终的$options</p>
<pre><code class="language-js">    // 当通过Vonde创建Component时会传入 options._isComponent
    if (options &amp;&amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
          // 获取构造函数上的options
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }</code></pre>
<p><code>resolveConstructorOptions</code>的作用是获取构造方法上的options对象。</p>
<p>此时的options对象是这样的。</p>
<pre><code class="language-js">{
    components: {
        KeepAlive
        Transition
        TransitionGroup
    },
    directives: {
        model
        show
    },
    filters: {

    },
    _base: Vue
}</code></pre>
<p><code>mergeOptions</code>的伪代码如下：</p>
<pre><code class="language-js">// parent: 从构造函数上获取的options
// child： 当前组件的options
// vm： 当前组件实例
function mergeOptions (parent, child, vm) {
  // 处理child的props, 转成统一的格式
  normalizeProps(child, vm)

  // 处理child的inject, 转成统一的格式
  normalizeInject(child, vm)

  // 当指令是一个function时需要转换成一个对象
  // 如果取值是一个function, 则默认bind和update的的值都是一样的
  normalizeDirectives(child)

  // 递归处理extends和mixins的情况
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i &lt; l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  // 用于保存最终合并得到的结果
  const options = {}
  let key
  for (key in parent) {
    mergeField(key)
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField (key) {
    // 不同的字段有不同的合并策略
    // TODO: 专门写一篇合并策略
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}</code></pre>
<p>此时的$options是这样的。</p>
<pre><code class="language-js">{
    components: {}
    directives: {}
    el: &quot;#app&quot;
    filters: {}
    render: ƒ render(h)
    _base: ƒ Vue(options)
}</code></pre>
<blockquote>
<p>注意： 此时，KeepAlive、 Transition、 TransitionGroup在components的原型上。</p>
<p>model、show在directives的原型上。</p>
<p>思考： 是否可以重写或者扩展show、model???</p>
</blockquote>
<h2 id="initlifecycle">initLifecycle</h2>
<pre><code class="language-js">  let parent = options.parent
  // 找到第一个非抽象组件的父级
  // 并且将当前组件push到parent.$children
  // $children包含了所有的子组件， 包括slot
  if (parent &amp;&amp; !options.abstract) {
    while (parent.$options.abstract &amp;&amp; parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  // renderWatcher
  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false</code></pre>
<h2 id="initevents">initEvents</h2>
<p>TODO: ???</p>
<pre><code class="language-js">function initEvents() {
  vm._events = Object.create(null)
  vm._hasHookEvent = false
  // init parent attached events
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
}</code></pre>
<h2 id="initrender">initRender</h2>
<p>伪代码：</p>
<pre><code class="language-js">function initRender (vm: Component) {
  // TODO:???
  vm._vnode = null // the root of the child tree
  vm._staticTrees = null // v-once cached trees
  const options = vm.$options

  // TODO: parentVnode是什么???
  const parentVnode = vm.$vnode = options._parentVnode 

  // TODO: 渲染上下文？
  const renderContext = parentVnode &amp;&amp; parentVnode.context

  // 获取当前组件的slot, slot是在父组件的作用域内编译的。
  // TODO: 单独写一篇slot编译的文章
  vm.$slots = resolveSlots(options._renderChildren, renderContext)

  // 作用域slot
  vm.$scopedSlots = emptyObject

  // 供template编译的render方法使用
  vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)

  // 供手写的render方法使用
  vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)

  const parentData = parentVnode &amp;&amp; parentVnode.data

  // 获取vnode对象上的attrs和_parentListeners
  defineReactive(vm, &#39;$attrs&#39;, parentData &amp;&amp; parentData.attrs || emptyObject, null, true)
  defineReactive(vm, &#39;$listeners&#39;, options._parentListeners || emptyObject, null, true)
}</code></pre>
<h2 id="执行beforecreate钩子">执行beforeCreate钩子</h2>
<p>执行用户的定义的breforeCreate钩子。</p>
<h2 id="initinjections">initInjections</h2>
<p>伪代码：</p>
<p>TODO:  后面写个具体的例子</p>
<pre><code class="language-js">function initInjections (vm: Component) {
    const result = resolveInject(vm.$options.inject, vm)
}</code></pre>
<h2 id="initstate">initState</h2>
<pre><code class="language-js">function initState (vm: Component) {
  // 用于保存当前组件对象的所有watcher对象。
  vm._watchers = []
  const opts = vm.$options

  // 初始化props
  if (opts.props) initProps(vm, opts.props)

  // 初始化methods
  if (opts.methods) initMethods(vm, opts.methods)

  // 初始化data
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }

  // 初始化computed
  if (opts.computed) initComputed(vm, opts.computed)

  // 初始化watch
  if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}</code></pre>
<h3 id="initprops">initProps</h3>
<pre><code class="language-js">function initProps (vm: Component, propsOptions: Object) {
  // TODO: ????
  const propsData = vm.$options.propsData || {}

  // TODO: 
  const props = vm._props = {}
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent

  if (!isRoot) {
    // TODO: 在observe内部将不会执行 new Observer(value)
    toggleObserving(false)
  }

  for (const key in propsOptions) {
    keys.push(key)
    // 校验prop的值
    // TODO：写个示例
    const value = validateProp(key, propsOptions, propsData, vm)

    defineReactive(props, key, value)

    // TODO: ???
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
}</code></pre>
<h3 id="initmethods">initMethods</h3>
<pre><code class="language-js">function initMethods (vm: Component, methods: Object) {
    // 逻辑比较简单， 只是遍历$options.methods
    // 将所有方法bind(vm)后挂在组件实例vm上
    // 这里bind方法会返回一个新的方法， 所以vm.$options.methods.xxxMethod != vm.xxxMethod
    for (const key in methods) {
        vm[key] = typeof methods[key] !== &#39;function&#39; ? noop : bind(methods[key], vm)
    }
}</code></pre>
<h3 id="initdata">initData</h3>
<pre><code class="language-js">function initData (vm: Component) {
    let data = vm.$options.data

    // 获取data对象
    // 当不是根组件是data是一个function，因为组件是可复用的， 所以必须在每次创建一个实例时使用不同的对象
    // 这里通过定义一个function来返回一个新的对象
    // TODO: 如果可服用的组件不使用function返回会有什么问题？ 是否有可以使用的场景恰好需要这样的效果？
    // TODO: 为什不直接执行data.call(vm, vm)， 而是通过getData来执行？
    data = vm._data = typeof data === &#39;function&#39;
    ? getData(data, vm)
    : data || {}

    const keys = Object.keys(data)
    const props = vm.$options.props
    const methods = vm.$options.methods
    let i = keys.length

    while (i--) {
        const key = keys[i]
        if (props &amp;&amp; hasOwn(props, key)) {
          // 生产环境的代码啥也不做^_^
        } else if (!isReserved(key)) {
          // isReserved(key)检查key是否以 $ 或 _ 开头
          // 将vm._data所有的属性代理到vm上
          // vm.xxx 即返回 vm._data.xxx
          proxy(vm, `_data`, key)
        }
    }

    // 将data对象变成所谓的响应式对象
    // 注意： data 和 vm._data 是同一个对象
    // 通过observe将data所有属性变成访问器属性
    observe(data, true /* asRootData */)
}</code></pre>
<p>proxy的代码如下</p>
<pre><code class="language-js">// 在上面的代码中 
// target: vm
// sourceKey: &#39;_data&#39;
// key： 遍历data时的每一个key
function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
      // 在访问vm.xx时，其实访问的是 vm._data.xx
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
  // 在vm.xx = xxx时，其实赋值的是 vm._data.xx = xxx
    this[sourceKey][key] = val
  }
  // target 定义 key 属性
  Object.defineProperty(target, key, sharedPropertyDefinition)
}</code></pre>
<p><strong>下面来讲下observe的逻辑， 这部分很重要</strong>。</p>
<p>废话不多说直接上代码：</p>
<pre><code class="language-js">// 接着上面的代码
// value: vm._data
// asRootData: true // 作为rootData
function observe (value: any, asRootData: ?boolean): Observer | void {
  // 如果不是一个对象， 或者是一个VNode对象将不做处理
  if (!isObject(value) || value instanceof VNode) {
    return
  }

  let ob: Observer | void
  // 如果当前对象的__ob__属性是一个 Observer 对象， 表示当前对象已经是一个响应式对象
  // 将会返回这个 Observer 对象
  if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &amp;&amp;
    !isServerRendering() &amp;&amp;
    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;
    Object.isExtensible(value) &amp;&amp;
    !value._isVue
  ) {
    // shouldObserve 是一个全局的开关
    // 不是服务端渲染
    // 是一个普通的对象或者是一个数组, 并且课扩展， 即可以在上面添加属性
    // 当前对象不是组件实例，每一个组件实例上都会有一个_isVue属性

    ob = new Observer(value)
  }
  if (asRootData &amp;&amp; ob) {
    ob.vmCount++
  }
  return ob
}</code></pre>
<p>observe方法里面最重要的逻辑就是 <code>new Observer(value)</code>。</p>
<p>Observer的代码如下：</p>
<pre><code class="language-js">class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
      // 原始对象和Observer对象会有一个相互引用
    this.value = value

    // TODO:???
    this.dep = new Dep()

    // TODO:???
    this.vmCount = 0

    // 相互引用
    def(value, &#39;__ob__&#39;, this)

    // 数组和对象分开始处理
    if (Array.isArray(value)) {
      // 如果是数组则通过在数组和数组原型之间加一层，增加原型链的长度。
      // 在增加的这一层原型上来监听用户对数组的操作。
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }

  // 对象
  // 将对象上的所有属性都转换为访问器属性， set/get
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i &lt; keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  // 数组将会遍历所有的项，递归调用observe
  observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])
    }
  }
}</code></pre>
<p>由上面的代码可以知道，数组和对象是分开处理的。</p>
<h4 id="普通对象的监听">普通对象的监听</h4>
<p>普通对象的处理逻辑是在walk方法里完成的。walk的代码逻辑比较简单， 无非就是遍历obj执行<code>defineReactive(obj, keys[i])</code>。那么defineReactive又做了什么呢？</p>
<h5 id="访问器属性">访问器属性</h5>
<pre><code class="language-js">// 接着上面的代码
// obj: vm._data
// key： 遍历vm._data时的属性值
// 假设 obj 的值为
  {
      message: [&#39;hello&#39;]    
  }
// key的值为message
function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // 每一个属性都有一个 Dep 对象来收集使用过当前属性的watch
  const dep = new Dep()

  // 获取当前属性的描述对象
  /*
  普通属性
  {
      configurable: boolean
      enumerable:  boolean
      value: any
      writable: boolean
  }
  访问器属性
  {
      configurable: boolean
      enumerable:  boolean
      set: function
      get: function
  }
  */
  const property = Object.getOwnPropertyDescriptor(obj, key)
  // 如果当前对象是不可配置的直接 return
  // 思考： 如果不想某个属性变成响应式，是否可以将该属性设置 configurable 为 false.
  if (property &amp;&amp; property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property &amp;&amp; property.get
  const setter = property &amp;&amp; property.set

  // 在这里val被缓存起来了
  // 此时 val 的值为 [&#39;hello&#39;]
  if ((!getter || setter) &amp;&amp; arguments.length === 2) {
    val = obj[key]
  }

  // 如果有需要也可以将当前的属性对应的也转换
  // 在这里因为没有传入shallow，所以在initData时也会将对象对应的子对象也作转换
  // val 的值为 [&#39;hello&#39;]
  // 在 observe 一个数组时， 处理的方式与普通对象的方式不一致。

  // 【非常重要】 缓存子对象的 obserevr 对象， 这在val 是一个数组的时候有用到。
  let childOb = !shallow &amp;&amp; observe(val)

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val

      // Dep.target 上会挂一个watcher对象
      // 当前 Dep.target 的值不为空时， 如果
      // 在这里收集watcher
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          // 【非常重要】 childOb.dep 收集依赖， 将会在增加的数组原型层中重写数组的原型方法时会用到。
          childOb.dep.depend()
          if (Array.isArray(value)) {
            // 数组元素也添加依赖
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter &amp;&amp; !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow &amp;&amp; observe(newVal)
      // 通知watcher
      dep.notify()
    }
  })
}</code></pre>
<h5 id="dep对象">Dep对象</h5>
<p>Dep对象是怎样收集依赖的呢？</p>
<p>每一个属性会对应一个dep对象， 当访问某个属性时，就会触发这个属性的set方法，这个dep对象会将Dep.target上的值（这个值是一个Watcher对象）push到dep.subs数组中，通过这种方式收集依赖。而当data的属性值改变时就会触发set方法， 在set方法内部调用dep.notify去执行每一个watcher的update方法。</p>
<pre><code class="language-js">class Dep {
  static target: ?Watcher;
  id: number;
  // 用于收及
  subs: Array&lt;Watcher&gt;;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  // 
  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  // Dep.target是一个Watcher对象
  // 在addDep方法里会调用 addSub 方法
  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    const subs = this.subs.slice()
    if (!config.async) {
      subs.sort((a, b) =&gt; a.id - b.id)
    }
    for (let i = 0, l = subs.length; i &lt; l; i++) {
      subs[i].update()
    }
  }
}

Dep.target = null

Dep.target = null
const targetStack = []

// 提供公开的方法用于将当前Watcher挂在Dep.target
// 作用是： 在执行Watcher的get方法时如果使用到响应式数据， 就会将当前
// 挂在Dep.target上的 Watcher 对象就会被响应式数据的dep对象收集起来。
export function pushTarget (target: ?Watcher) {
  targetStack.push(target)
  Dep.target = target
}

export function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}</code></pre>
<h5 id="watcher对象">Watcher对象</h5>
<p>那么 Wathcer 对象又是什么呢？</p>
<pre><code class="language-js">class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array&lt;Dep&gt;;
  newDeps: Array&lt;Dep&gt;;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm

    // renderWatcher
    if (isRenderWatcher) {
      vm._watcher = this
    }

    // 将watcher对象push到_watchers
    vm._watchers.push(this)
    // options
    if (options) {
      // userWatcher的时候会用到
      this.deep = !!options.deep
      this.user = !!options.user
      // 创建computedWatcher的时候会用到
      this.lazy = !!options.lazy
      // 同步执行， userWatcher的时候会用到
      this.sync = !!options.sync
      // before会在创建renderWatcher时候用到
      this.before = options.before
    } else {
      this.deep = this.user = this.lazy = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true

    // 在computed属性中会用到
    this.dirty = this.lazy // for lazy watchers

    // 上一次的依赖
    this.deps = []

    // 存放当前watcher使用过的响应式数据的dep对象
    this.newDeps = []
    // 上一次的dep id集合
    this.depIds = new Set()
    // 存放当前watcher使用过的响应式数据的dep对象的id
    this.newDepIds = new Set()

    this.expression = process.env.NODE_ENV !== &#39;production&#39;
      ? expOrFn.toString()
      : &#39;&#39;

    // parse expression for getter
    // 可能是_render方法， 也可能是computed的get方法
    if (typeof expOrFn === &#39;function&#39;) {
      this.getter = expOrFn
    } else {
      // 如果是一串类似&#39;a.b.c&#39;的字符串则是用户定义的watch
      // parsePath返回一个方法
      this.getter = parsePath(expOrFn)
      // 如果通过’a.b.c&#39;获取不到值则会发出警告
      if (!this.getter) {
        this.getter = noop
        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(
          `Failed watching path: &quot;${expOrFn}&quot; ` +
          &#39;Watcher only accepts simple dot-delimited paths. &#39; +
          &#39;For full control, use a function instead.&#39;,
          vm
        )
      }
    }

    // Wathcer的value的值是执行getter方法的返回值
    // 因为computed是惰性求值，所以通过lazy=true来标识，不会立即求值
    this.value = this.lazy
      ? undefined
      : this.get()
  }

  // 在useWatcher 和 renderWacth 会立即执行get方法
  get () {
    // 将当前 Watcher 对象挂在 Dep.target 上
    pushTarget(this)

    let value
    const vm = this.vm

    try {
      // 执行gettr 方法
      // 这里有三种情况： 
      // renderWtahcer: VNode
      // computedWathcer: 用户定义的返回值， 可以是任何类型
      // userWatcher： parsePath(&#39;a.b.c&#39;)()解析得到的值
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)
      } else {
        throw e
      }
    } finally {
      // 如果userWatcher是监听一个对象， 并且是深度监听
      // 则会通过遍历这个对象的方式让这个对象所有的属性的dep收集当前watcher作为依赖
      if (this.deep) {
        traverse(value)
      }

      // 将Watcher从Dep.target上移除
      popTarget()
      this.cleanupDeps()
    }
    return value
  }

  // 这个方法会在dep.depend内部调用
  // 执行完后，dep会将watcher push到dep.subs
  // 同时会将dep push 到watcher.newDeps
  // 相互收集的目的是：
  // dep 收集 watcher 是为了方便在 数据改变时通过dep去通知watcher
  // wathcer 收集 dep 为了方便在watcher销毁时将wather从dep.subs中移除
  // 思考: 为什么需要newDepIds和depIds两层判断？？？
  // 因为get 在组件的交互过程中可能会执行多次，所以需要用depIds保存上一次执行get时收集的依赖
  // newDepIds 保存这一次收集的依赖
  addDep (dep: Dep) {
    const id = dep.id
    // 这里会将所有的dep push 到newDeps
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      // 如果上一次已经有这个dep, 那么将不会重复执行addSub,
      // 原因请看cleanupDeps方法的代码
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  // 更新this.deps
  cleanupDeps () {
    let i = this.deps.length

      // 将wathcer从上一次收集的依赖的subs中移除
      // 这里只移除newDepIds中没有的dep
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }

    // 将newDeps赋值给deps, 清空newDeps
    // 将newDepIds赋值给depIds，清空newDepIds
    // 思考： 直接用newDeps替换deps, 那在上一次不被清除的dep对象会不会不在newDeps里面？
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }

  // dep通知wathcer时， 会执行updeate方法
  // 参考Dep的 notify 方法
  update () {
    /* istanbul ignore else */
    if (this.lazy) { // computed
      this.dirty = true
    } else if (this.sync) { // user
      this.run()
    } else { // render
      queueWatcher(this)
    }
  }

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  run () {
    // active 标识watcher是否已经销毁
    if (this.active) {
      // 重新计算值
      const value = this.get()
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        const oldValue = this.value
        this.value = value
        if (this.user) {
          try {
            // 执行回调函数
            this.cb.call(this.vm, value, oldValue)
          } catch (e) {
            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)
          }
        } else {
          this.cb.call(this.vm, value, oldValue)
        }
      }
    }
  }

  // computed
  evaluate () {
    this.value = this.get()
    this.dirty = false
  }

  /**
   * Depend on all deps collected by this watcher.
   */
  depend () {
    let i = this.deps.length
    while (i--) {
      this.deps[i].depend()
    }
  }

  // 销毁wacther对象
  teardown () {
    if (this.active) {
      // remove self from vm&#39;s watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this)
      }
      let i = this.deps.length
      while (i--) {
        this.deps[i].removeSub(this)
      }
      this.active = false
    }
  }
}</code></pre>
<blockquote>
<p>总结：</p>
<p>vm、_data、Observer、Dep、Watcher 之间的关系</p>
<p>vm: 当前组件实例。vm.$data代理了_data。vm. _watchers 保存了所有的wathcer对象。</p>
<p>_data : options.data的原始对象。new Observer(_data)将data的所有属性转化成访问器属性，data.<strong>ob</strong>指向该observer对象。同时每个属性都会在闭包中缓存一个dep对象。dep对象将会在get方法内部收集依赖， 在set方法内部通知依赖。</p>
<p>Observer：将data的属性转换成访问器属性。</p>
<p>Dep： Dep是在new Observer(data)的时候在闭包内创建的。dep对象是data和watcher相互联系的桥梁。</p>
<p>Watcher：有三种watcher，renderWathcer、computedWatcher、userWatcher。</p>
<p>watcher在创建的时候会将当前watcher挂在Dep.target上， 求值的过程中使用data中的数据时会触发get方法， 在get方法内部dep对象r收集 当前watcher。</p>
<p>data  通过 Dep 收集依赖， data通过Dep通知对象。</p>
</blockquote>
<h4 id="数组的监听">数组的监听</h4>
<p>监听数组要考虑的情况有三种：</p>
<p>以监听下面的对象为示例说明。</p>
<pre><code class="language-js">var arr = [
    &#39;hello&#39;,
    {
        a:&#39;a&#39;
    }
]
var data = {
    message: arr
}</code></pre>
<blockquote>
<p>修改 data.message。</p>
</blockquote>
<p>data是一个对象所以在observe(data)的时候会走walk的逻辑。所以能监听到data.message的赋值操作，这与普通的对象没什么区别。</p>
<blockquote>
<p>操作数组本身，而不操作元素本身。</p>
</blockquote>
<p>数组本身操作的监听是通过增夹中间层原型来实现的。在重写的方法内部会通过arr.<strong><strong>ob</strong></strong>.dep.notify()通知依赖。值得注意的是，在执行defineReactive(data, &#39;message&#39;)的时候。会在内部observe(arr)并且将返回的observer对象缓存在childOb变量上。childOb.dep.depend()会收集依赖。</p>
<blockquote>
<p>操作数组元素， 数组本身没有操作。</p>
</blockquote>
<p>通过遍历observe数组的每一个元素。实际上当数组元素是一个基础类型时重新赋值vue并不会感知到，</p>
<p>比如这里的 data.message[0] = &#39;new value&#39;, 必须使用$set去赋值。</p>
<blockquote>
<p>不能被vue感知到的数组操作。</p>
</blockquote>
<ol>
<li>data[0] = &#39;newValue&#39;</li>
<li>data.length = 0</li>
</ol>
<pre><code class="language-js">// 数组本来的原型
const arrayProto = Array.prototype
// 以数组本来的原型创建一个对象，这个对象的原型就是arrayProto
// 这样就在原型链上加了一个原型
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  &#39;push&#39;,
  &#39;pop&#39;,
  &#39;shift&#39;,
  &#39;unshift&#39;,
  &#39;splice&#39;,
  &#39;sort&#39;,
  &#39;reverse&#39;
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // 缓存原有的方法
  const original = arrayProto[method]

  // 重写方法， 在方法内部进行数组操作的拦截
  def(arrayMethods, method, function mutator (...args) {
    // 调用原始的方法
    const result = original.apply(this, args)

    // 获取当前数组的Observer对象
    // 【非常重要】 参考defineReactive方法的代码
    // this.__ob__是在执行 childOb.dep.depend() 的时候收集依赖的
    const ob = this.__ob__

    let inserted
    switch (method) {
      case &#39;push&#39;:
      case &#39;unshift&#39;:
        inserted = args
        break
      case &#39;splice&#39;:
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)

    // 通知watcher
    ob.dep.notify()
    return result
  })
})</code></pre>
<h3 id="initcomputed">initComputed</h3>
<p>以下面的代码为例。</p>
<pre><code>computed: {
    msg() {
        return this.message
    }
}</code></pre><pre><code class="language-js">// computed 是用户定义的 option.computed 对象
function initComputed (vm: Component, computed: Object) {
    // 在组件实例上的_computedWatchers属性上保存了所有computedWatcher
    const watchers = vm._computedWatchers = Object.create(null)

    for (const key in computed) {
        const userDef = computed[key]
        // 获取用户定义的get方法, 如果是function则把这个function作为get方法
        const getter = typeof userDef === &#39;function&#39; ? userDef : userDef.get

        if (!isSSR) {
          // 每一个computed属性 都会创建一个对应的 Wathcer 对象
          // computedWatcherOptions: { lazy: true }
          // 这里的lazy的值为true， 在创建Watcher对象的时候会惰性求值
          // 
          watchers[key] = new Watcher(
            vm,
            getter || noop,
            noop,
            computedWatcherOptions
          )
        }

        // 会判断vm是否已经存在，开发环境会抛出警告
        if (!(key in vm)) {
          defineComputed(vm, key, userDef)
        } 
    }
}</code></pre>
<p>defineComputed的伪代码如下：</p>
<pre><code class="language-js">// target: vm
// key: computedName
// userDef: 用户定义的对象或函数
function defineComputed (
  target: any,
  key: string,
  userDef: Object | Function
) {
  // 不是服务端渲染  
  const shouldCache = !isServerRendering()
  //
  // 这里有两种情况： 
  // 缓存watcher的值时使用createComputedGetter创建get
  // 不缓存watcher的值时使用createGetterInvoker创建get
  // 用户定义的是function
  if (typeof userDef === &#39;function&#39;) {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef)
    // 未定义set使用空方法赋值
    sharedPropertyDefinition.set = noop
  } else { // 用户定义的是object
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache &amp;&amp; userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop
    // 如果使用了则直接赋值
    sharedPropertyDefinition.set = userDef.set || noop
  }

  // 讲 key 定义为访问器属性， 与普通的访问器不同的是， computed的get方法的返回值
  // 是watcher的value
  // 默认会通过watcher做缓存
  Object.defineProperty(target, key, sharedPropertyDefinition)
}</code></pre>
<p>createComputedGetter</p>
<pre><code class="language-js">function createComputedGetter (key) {
  return function computedGetter () {
    // 取得当前computed属性的computedWatcher
    const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]

    if (watcher) {
      // 重新求值
      // dirty 的初始值为true
      // 在evaluate内部会调用watcher.get() 方法
      // 在watcher.get()执行完后，dirty的值变为false
      // 在下一次获取computed属性的值时，将不会再重新求值。
      // 这样能做到缓存的目的
      // 思考： 如果computed属性的依赖改变后怎么去更新值？
      if (watcher.dirty) {
        watcher.evaluate()
      }

      // 此时 Dep.taregt 指向的是 renderWatcher 
      // 这里会把renderWatcher push到 computedWathcer 的所有依赖dep对象的subs数组中。
      // 思考： 当computed属性的依赖改变时， 将会发生那些事情？
      // 1、修改watcher.dirty的值为true。
      // 2、通知renderWatcher重新渲染。
      // 3、在执行render方法的过程中会重新执行当前这个getter方法，此时watcher.dirty = true
      //    所以会通过watcher.evaluate()来重新计算computed的值。
      // 所以，本质上是computedWatcher的依赖最终也会变成renderWatcher的依赖。
      // 可以把computed属性看成是一组依赖的集合， 当render方法使用这个computed属性时就会
      // 依赖这个集合里所有的数据， 当这个集合里的某个数据发生改变时，将会出发renderWatcher的update
      // 方法。 在update时又会异步调用render方法， render方法内部使用这个computed属性时执行当前方法，
      // 导致重新求值(PS: 实际上此时在任何地方访问这个computed属性都会重新求值)。
      if (Dep.target) {
        watcher.depend()
      }

      // 返回watcher的值
      return watcher.value
    }
  }
}</code></pre>
<p>createGetterInvoker</p>
<p>不缓存结果， 每次执行都会执行。</p>
<pre><code class="language-js">function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}</code></pre>
<h3 id="initwatch">initWatch</h3>
<p>主要逻辑是 <code>createWatcher(vm, key, handler)</code></p>
<pre><code class="language-js">function initWatch (vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key]
    // 数组
    if (Array.isArray(handler)) {
      for (let i = 0; i &lt; handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}</code></pre>
<p>createWatcher</p>
<pre><code class="language-js">function createWatcher (
  vm: Component,
  expOrFn: string | Function,
  handler: any,
  options?: Object
) {
  // handler 是一个对象
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  // handler 是一个字符串则直接从vm上找对应的方法
  if (typeof handler === &#39;string&#39;) {
    handler = vm[handler]
  }

  // 最终还是调用$watch方法
  // expOrFn： 要监听的变量
  // hanler: 回调
  // options: 配置
  return vm.$watch(expOrFn, handler, options)
}
</code></pre>
<p>$watch</p>
<pre><code class="language-js">Vue.prototype.$watch = function (
  expOrFn: string | Function,
  cb: any,
  options?: Object
): Function {
  const vm: Component = this
  // 如果是用户直接使用$watch，那么cb可能是一个对象
  // 那么就使用createWatcher先处理下
  if (isPlainObject(cb)) {
    return createWatcher(vm, expOrFn, cb, options)
  }
  options = options || {}
  options.user = true

  // 创建 watcher 对象
  // 创建对象的过程中会通过expOrFn路径解析对象
  // 在执行get的过程中收集依赖， 也就是要监听的属性。
  // 当属性变化后则会执行回调
  const watcher = new Watcher(vm, expOrFn, cb, options)

  // 如果immediate的值为true, 则会立即执行回调函数
  if (options.immediate) {
    try {
      cb.call(vm, watcher.value)
    } catch (error) {
      handleError(error, vm, `callback for immediate watcher &quot;${watcher.expression}&quot;`)
    }
  }

  // 返回一个方法， 用于销毁watcher对象
  return function unwatchFn () {
    watcher.teardown()
  }
}</code></pre>
<h2 id="initprovide">initProvide</h2>
<h2 id="执行created钩子">执行created钩子</h2>
<p>执行用户定义的create钩子。</p>
<h2 id="mount">$mount</h2>
<p>现在我们回到入口文件 <code>web/entry-runtime-with-compiler.js</code>。发现Vue.prototype.$mount被重写了（上面也有提到过这个问题），这是因为我们学习的是runtime + compiler版本的， 和runtme不同的是， runtime版本一般是在webpack等构建工具使用， 因为在使用webpack打包代码的时候，template已经被编译成render方法了， 所以在生产环境其实是不需要compiler的。 但是如果不预先将template编译成render方法， 这就需要在运行的时候去编译， 这种情况就需要runtime + compiler版本的vue。所以$mount在不同的版本中是有差异的。</p>
<p>runtime + compiler的$mount方法 比runtime 的$mount多了一个template编译成render 的逻辑。</p>
<h3 id="编译template生成render方法">编译template生成render方法</h3>
<pre><code class="language-js">// 缓存运行时版本的$mount方法
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
    // 获取DOM元素
    el = el &amp;&amp; query(el)

    const options = this.$options
    // 如果不存在render方法，将会去获取template, 并将template转换成render方法。
    if (!options.render) {
       // TODO: 这里比较简单，后面有时间在补充说明
    }

    // 最后执行缓存的$mount方法
    return mount.call(this, el, hydrating)
}</code></pre>
<p>由于tmplate的编译过程比较复杂， 所以打算单独写一篇文章详细说明，这里就不在深入，我们直接从tempalte编译成render之后的逻辑开始学习。</p>
<p>所以，我们还是回到了 <code>runtime/index.js</code>下的$mount方法。</p>
<p>代码如下：</p>
<pre><code class="language-js">// 没有什么逻辑， 内部调用了mountComponent
// 直接看 mountComponent 的逻辑就好了
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el &amp;&amp; inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}</code></pre>
<p><code>mountComponent</code>方法是在 <code>core/instance/lifecycle</code> 定义的。</p>
<h3 id="执行beforemount钩子">执行beforeMount钩子</h3>
<pre><code class="language-js">function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el

  // 如果没有render方法， 则赋值一个返回emptyVNode的方法。
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
  }

  // 执行beforeMount钩子
  callHook(vm, &#39;beforeMount&#39;)

  let updateComponent
  // 用于更新组件
  updateComponent = () =&gt; {
    vm._update(vm._render(), hydrating)
  }

  // 创建renderWatcher
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted &amp;&amp; !vm._isDestroyed) {
        callHook(vm, &#39;beforeUpdate&#39;)
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // 通过$vone做判断，避免多次执行 mounted 钩子
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, &#39;mounted&#39;)
  }

  return vm
}</code></pre>
<p>主要的逻辑都在创建renderWatcher的过程中， 所以我们接下来看下创建renderWatcher的过程。</p>
<p>updateComponent方法将会作为watcher的getter,  在get方法内执行。</p>
<p>在执行updateComponent的时候， 内部调用了：</p>
<pre><code> vm._update(vm._render(), hydrating)</code></pre><h3 id="执行render方法生成vnode">执行render方法生成VNode</h3>
<p><code>vm._render()</code> 生成VNode, <code>vm._update</code>内部将会对vNode进行patch, 在patch的过程中会生成真实的DOM元素。</p>
<p>_render方法是在 <code>render.js</code>文件内的renderMixin方法内定义的。</p>
<pre><code class="language-js">Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    // TODO: ???
    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      )
    }

    // TODO：？？？
    vm.$vnode = _parentVnode


    let vnode
    try {
      // 模块内的一个全局变量
      currentRenderingInstance = vm
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {}
    finally {
      currentRenderingInstance = null
    }


    // 如果生成的vnode是一个数组， 并且数组的长度为1
    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) {
      vnode = vnode[0]
    }

    vnode.parent = _parentVnode
    return vnode
}</code></pre>
<h3 id="对新旧vnode进行patch">对新旧VNode进行patch</h3>
<p>_update是在 <code>lifecycle.js</code>   的lifecycleMixin方法内定义的。</p>
<pre><code class="language-js">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  // 组件实例对应的DOM元素
  const prevEl = vm.$el
  const prevVnode = vm._vnode

  // 将当前的vm对象赋值给 activeInstance
  // 并且在闭包内缓存上一个activeInstance
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode

  // Vue.prototype.__patch__ is injected in entry points
  // based on the rendering backend used.
  if (!prevVnode) {
    // initial render
    // 第一次执行patch
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    // 组件更新的时候
    vm.$el = vm.__patch__(prevVnode, vnode)
  }

  //将上一个activeInstance重新赋值给 activeInstance
  restoreActiveInstance()

  // update __vue__ reference
  if (prevEl) {
    prevEl.__vue__ = null
  }

  //在组件渲染的DOM上都会有一个__vue__属性执行当前组件实例   
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }

  // if parent is an HOC, update its $el as well
  // TODO: 高阶组件？？？
  if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
  // updated hook is called by the scheduler to ensure that children are
  // updated in a parent&#39;s updated hook.
}</code></pre>
<p><strong>patch的逻辑</strong></p>
<pre><code class="language-js">function createPatchFunction () {
  // 此处省略一大段代码...
  return function patch (oldVnode, vnode, hydrating, removeOnly) {

    // 如果vnode不存在
    if (isUndef(vnode)) {
      // 销毁oldVnode
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []


    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {
      const isRealElement = isDef(oldVnode.nodeType)
      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            } else if (process.env.NODE_ENV !== &#39;production&#39;) {
              warn(
                &#39;The client-side rendered virtual DOM tree is not matching &#39; +
                &#39;server-rendered content. This is likely caused by incorrect &#39; +
                &#39;HTML markup, for example nesting block-level elements inside &#39; +
                &#39;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#39; +
                &#39;full client-side render.&#39;
              )
            }
          }

          // oldVnode是一个dom元素，通过它创建一个空的VNode对象
          oldVnode = emptyNodeAt(oldVnode)
        }

        // replacing existing element
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)

        // create new node
        createElm(
          vnode, // VNode对象
          insertedVnodeQueue, // TODO:???
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm, // oldElm的父DOM元素
          nodeOps.nextSibling(oldElm) // oldElm的下一个兄弟元素，可能是元素节点也可能是文本节点
        )

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i &lt; cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i &lt; cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the &quot;inserted&quot; hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i &lt; insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
    return vnode.elm
  }
}</code></pre>
<h3 id="执行mounted钩子">执行mounted钩子</h3>

            </article> 
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>  
          </body>
      </html>