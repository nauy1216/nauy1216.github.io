### 1、对象属性类型



#### 1、数据属性特性

[[configurable]]

:

可重新配置的。设置为false后不可逆转，不能再设置属性的特性。 delel writeable 可修改为访问器属性均不可重新配置。

[[enumerable]]

：可遍历的。

[[writeable]]

：可修改的。

[[value]]

：属性的值，读写操作。

注意：

在对象上直接定义的属性，所有特性的值均为true。

采用Object.defineProperty()定义的，如不指定均为false。

#### 2、访问器属性特性

[[configurable]]

:可重新配置的。用法与上面一样。

[[enumerable]]

：可遍历的。默认true

[[set]]

：写 默认undefined

[[get]]

：读 默认undefined

注意：

访问器属性只能通过Object.defineProperty()定义。

读访问器属性时，触发get()函数。

写访问器属性时，触发set()函数。

作用：

 可以用来监听访问器属性的变化。



### 2、定义属性



#### 1、Object.defineProperty();

作用

：定义一个对象的属性，并且定义属性的特性。

用法

：必须有三个参数。

（1）定义数据属性

定义属性的同时，设置属性的特性。

```
    var person = {};

    Object.defineProperty(person,"name",{
        configurable:true,
        enumerable:true,
        writable:false,//不可修改
        value:"liuchengyuan"
    });

    console.log(person.name);//liuchengyuan
    person.name = "keke";
    console.log(person.name);//liuchengyuan
```

设为configurable:false后,不可逆转。其他的特性可多次设置。

```
    var person = {};

    Object.defineProperty(person,"name",{
        configurable:false,
        value:"liuchengyuan"
    });

    person.name = "keke";
    console.log(person.name);//liuchengyuan
    delete person.name;
    console.log(person.name);//liuchengyuan

    Object.defineProperty(person,"name",{//报错，不可逆转
        configurable:true,
        value:"liuchengyuan"
    });
```

（2）定义访问器属性



```
    var book= {
        year:2006
    };

    Object.defineProperty(book,"year",{//将数据属性year，变成访问器属性。
        configurable:true,
        get:function(){         //每次读取year时触发
            alert("读取数据了");
            return book.$year;
        },
        set:function(newValue){  //每次改写year时触发
            alert("改动数据了");
            this.$year = newValue;
            //不能给自己赋值，要不会连续触发set函数。
        }
    });

    book.year = 2007;//写
    book.year;//读
```

#### 2、Object.definePropertys()

同时定义多个属性。



```
    var book = {};

    Object.definePropertys(book,{
        _year:{
            writable:true,
            value:2004
        },
        edition:{
            writable:true,
            value:1
        },
        year:{
            get:function(){
                 return this._year;
            },
            set:function(){
                this.value = this._year;
            }
        }
    });
```



### 3、创建对象的方式



#### （1）对象字面量

```
    var Person = {
        name:"liu",
        sayName:function(){

        }
    };
```

#### （2）工厂模式

```
    function Person(name){
        var o = new Object();

        o.name = name;
        o.sayName = function(){
            alert(this.name);
        };

        return o;
    }

    Person("liu").sayName();

    ----------------------

    function Person(name){
        var sayName = function(){
            alert(this.name);
        };
        return{
            "name":name,
            "sayName":sayName
        };
    }
    Person("liu").sayName();
```

#### （3）构造函数模式

有对象类型,能有对象识别。



```
    function Person(name){
        this.name = name;
        this.sayName = function(){
            alert(this.name);
        };
    }

    var p = new Person("liu");
    p.sayName();//liu
```

#### （4）原型模式

prototype：

 构造函数的属性，指向原型对象。

constructor：

 原型对象的属性，指向构造函数。 如果重写对象，则会改变这个指向。

原型对象：

用于保存所有的实例对象共享的属性和方法。

例如：

Person.prototype = {};

此时Person.prototype.constructor指的是{}的构造函数。这是因为Person的原型{}并没有 constructor属性，于是从{}的原型查找。

可以重新指向：Person.prototype.constructor = Person；

构造函数（也是对象）与原型对象的关系

：

Person.prototype ======> 原型对象

Person.prototype.constructor ======> 构造函数

实例对象访问属性的过程：

首先访问自己私有的属性，如果没有则访问原型对象的同名属性。

```
    function Person(){

    }
    Person.prototype.name  = "liu";
    Person.prototype.sayName = function(){
        alert(this.name);
    };
```

#### （5）构造函数加原型模式

```
    function Person(name){
        this.name  = name;
    }

    Person.prototype.sayName = function(){
        alert(this.name);
    };
```

#### （6）动态混合模式

```
    function Person(name){
        this.name  = name;

        if(typeof this.sayName != "function"){
            Person.prototype.sayName = function(){
                alert(this.name);
            };
        }
    }
```



### 4、继承

在js里，继承主要有两个部分，继承属性和继承方法。 下面举个例子，先定义Person对象，然后定义Worker继承Person对象。

```
    //Person对象
    function Person(name){
        this.name =  name;
    }

    Person.prototype.sayName = function(){
        alert(this.name);
    }
```

#### （1）继承属性

通过调用父类的构造函数，改变this的指向，来继承所有父类的属性。

```
    function Worker(name ,age){
        this.age = age;
        Person.call(this,name);
    }
```

#### （2）继承方法

第一种方法：直接引用原型。



```
    Worker.prototype = Person.prototype;
    Worker.prototype.constructor = Worker;
```

问题：父类对象与子类对象不能通过instance区分。

第二种方法：原型为通过父类原型新创建的一个对象。（完美）



```
    inherit(Worker,Person);//继承方法

    function inherit(sub,sup){
        var prototype = object(sup.prototype);
        prototype.constructor = sub;
        sub.prototype = prototype;

        function object(o){
            function F(){}
            F.prototype = o;
            return new F();
        }

    }
```

第三种方法：遍历父类原型，拷贝成一个新的对象，作为子类的原型。



```
    var person = {};

    for(var attr in Person.prototype){
        person[attr] = Person.prototype[attr];
    }

    Worker.prototype = person;
```

问题：切断了子类与父类的联系，虽然有了父类的全部方法。



### 5、对象的一些常用方法属性

（1）instanceof:
判断某个实例对象的类型
p1 instanceof Person

（2）isPrototypeOf()：
判断某个实例对象的原型
Person.prototype.isPrototypeOf(p1)

（3）Object.getPrototypeOf():
返回某个实例对象的原型
Object.getPrototypeOf(p1)；

（4）delete：删除对象的某个属性。

（5）hasOwnProperty():
判断某个实例对象是否有某个私有属性
p1.hasOwnProperty("name")

(6)Object.getOwnPropertyDescriptor();
作用：获取对象某个属性的特性。返回一个对象。
var d = Object.getOwnPropertyDescriptor(book,"year");
alert(d.set);

（7） in
"name" in p1 判断name 是否是p1的属性，不管是私有还是原型的。

（8）for in
遍历实例对象的属性，包括私有和原型属性。只能访问可枚举的属性。
（9）Object.keys()
返回一个数组，包含实例对象的所有属性，不包括原型的属性。

（10）Object.getOwnPropertyNames()
所有的属性，包括不可枚举的属性。
Object.getOwnPropertyNames(Person.prototype)

### 6、想要知道某个对象类型

原型的constructor 指向了构造函数,这是唯一的，这可以重新定向。 但如果有多个构造函数的原型都指向同一个对象的原型， 那么 instanceof 得到的结果可能不准确。
比如：

```
    Worker.prototype = Person.prototype;
    Y.prototype = Person.prototype;
    //Worker.prototype.constructor = Worker;//

    var p = new Person("li");
    var w = new Worker("li",22);
    var y = new Y();

    alert(Object.getPrototypeOf(p).constructor === Person);//true
    alert(Object.getPrototypeOf(p).constructor === Worker);//false
    alert(Object.getPrototypeOf(p).constructor === Y);//false
    alert(Object.getPrototypeOf(w).constructor === Person);//true
    alert(Object.getPrototypeOf(w).constructor === Worker);//false
    alert(Object.getPrototypeOf(w).constructor === Y);//false
    alert(Object.getPrototypeOf(y).constructor === Person);//true
    alert(Object.getPrototypeOf(y).constructor === Worker);//false
    alert(Object.getPrototypeOf(y).constructor === Y);//false

    alert(p instanceof Worker);//true
    alert(p instanceof Y);//true
    alert(w instanceof Person);//true
    alert(w instanceof Worker);//true
    alert(w instanceof Y);//true
    alert(y instanceof Person);//true
    alert(y instanceof Worker);//true
    alert(y instanceof Y);//true
```